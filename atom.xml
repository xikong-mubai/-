<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>汐白的学习档案</title>
  
  <subtitle>小萌新一枚QAQ</subtitle>
  <link href="http://xibai.xyz/atom.xml" rel="self"/>
  
  <link href="http://xibai.xyz/"/>
  <updated>2024-07-19T03:45:30.000Z</updated>
  <id>http://xibai.xyz/</id>
  
  <author>
    <name>Xibai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最近更新</title>
    <link href="http://xibai.xyz/2023/06/26/recently/"/>
    <id>http://xibai.xyz/2023/06/26/recently/</id>
    <published>2023-06-26T03:46:30.000Z</published>
    <updated>2024-07-19T03:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="这里列出最近有更新过的内容"><a href="#这里列出最近有更新过的内容" class="headerlink" title="这里列出最近有更新过的内容"></a>这里列出最近有更新过的内容</h2><h3 id="07-19"><a href="#07-19" class="headerlink" title="07.19"></a>07.19</h3><h4 id="不同云服务商的云服务器搭建k8s集群"><a href="#不同云服务商的云服务器搭建k8s集群" class="headerlink" title="[不同云服务商的云服务器搭建k8s集群]"></a>[不同云服务商的云服务器搭建k8s集群]</h4><h3 id="11-15"><a href="#11-15" class="headerlink" title="11.15"></a>11.15</h3><h4 id="2021-L3HCTF-SpecialRain-Writeup"><a href="#2021-L3HCTF-SpecialRain-Writeup" class="headerlink" title="2021-L3HCTF_SpecialRain-Writeup"></a><a href="http://xibai.xyz/2021/11/15/2021-L3HCTF/">2021-L3HCTF_SpecialRain-Writeup</a></h4><h3 id="09-08"><a href="#09-08" class="headerlink" title="09.08"></a>09.08</h3><h4 id="域前置"><a href="#域前置" class="headerlink" title="域前置"></a><a href="http://xibai.xyz/2021/09/08/DomainFronting/">域前置</a></h4><h3 id="09-03"><a href="#09-03" class="headerlink" title="09.03"></a>09.03</h3><h4 id="常见取证总结"><a href="#常见取证总结" class="headerlink" title="常见取证总结"></a><a href="http://xibai.xyz/2021/09/03/evidence-1/">常见取证总结</a></h4><h3 id="08-30"><a href="#08-30" class="headerlink" title="08.30"></a>08.30</h3><h4 id="c2服务器隧道代理分析"><a href="#c2服务器隧道代理分析" class="headerlink" title="c2服务器隧道代理分析"></a><a href="http://xibai.xyz/2021/08/30/reGrorg/">c2服务器隧道代理分析</a></h4><h3 id="08-12"><a href="#08-12" class="headerlink" title="08.12"></a>08.12</h3><h4 id="DNS-Tunnel-分析"><a href="#DNS-Tunnel-分析" class="headerlink" title="DNS_Tunnel 分析"></a><a href="http://xibai.xyz/2021/08/12/DNS_Tunnel/">DNS_Tunnel 分析</a></h4>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    
  </entry>
  
  <entry>
    <title>C++_study</title>
    <link href="http://xibai.xyz/2023/01/04/c-study/"/>
    <id>http://xibai.xyz/2023/01/04/c-study/</id>
    <published>2023-01-04T06:44:46.000Z</published>
    <updated>2023-01-04T06:44:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-C-记录"><a href="#C-C-记录" class="headerlink" title="C/C++ 记录"></a>C/C++ 记录</h2><h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><p>参考</p><ul><li><a href="https://jiuaidu.com/jianzhan/927554/">https://jiuaidu.com/jianzhan/927554/</a></li><li><a href="https://blog.csdn.net/qq_19257541/article/details/116149170">https://blog.csdn.net/qq_19257541/article/details/116149170</a></li></ul><h3 id="信号量机制复习"><a href="#信号量机制复习" class="headerlink" title="信号量机制复习"></a>信号量机制复习</h3><p>参考</p><ul><li><a href="https://blog.csdn.net/u013271656/article/details/114537411">https://blog.csdn.net/u013271656/article/details/114537411</a></li><li><a href="https://blog.csdn.net/fengbingchun/article/details/92074191/">https://blog.csdn.net/fengbingchun/article/details/92074191/</a></li></ul><h3 id="libevent-参考学习"><a href="#libevent-参考学习" class="headerlink" title="libevent 参考学习"></a>libevent 参考学习</h3><ul><li><a href="https://blog.csdn.net/weixin_36750623/article/details/83855731">https://blog.csdn.net/weixin_36750623/article/details/83855731</a></li></ul><h3 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h3><ul><li><a href="https://www.cnblogs.com/L0g4n-blog/p/12839171.html">https://www.cnblogs.com/L0g4n-blog/p/12839171.html</a></li></ul>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="C/C++" scheme="http://xibai.xyz/categories/C-C/"/>
    
    
    <category term="Code" scheme="http://xibai.xyz/tags/Code/"/>
    
    <category term="C/C++" scheme="http://xibai.xyz/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>Qemu_use-Log</title>
    <link href="http://xibai.xyz/2022/12/02/qemu-use-log/"/>
    <id>http://xibai.xyz/2022/12/02/qemu-use-log/</id>
    <published>2022-12-02T07:05:45.000Z</published>
    <updated>2022-12-02T07:05:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><del>~找到一个 09 年的工具仓库，建议本文直接废弃555</del>~</p><h2 id="qemu"><a href="#qemu" class="headerlink" title="qemu"></a>qemu</h2><p>QEMU 是一个快捷的跨平台开源计算机模拟器，可以模拟许多硬件体系结构（<strong>在模拟固件设备时操作非常方便</strong>，一般<code>IoT</code>设备的虚拟机往往使用<code>qemu</code>来模拟）。QEMU 可让您在现有系统（VM 主机服务器）之上运行未经修改的完整操作系统 (VM Guest)。您还可以使用 QEMU 进行调试 — 可以轻松停止正在运行的虚拟机、检查其状态、保存并在以后恢复其状态。</p><p>QEMU 主要由以下部分构成：</p><ul><li>处理器模拟器。</li><li>模拟的设备，例如显卡、网卡、硬盘或鼠标。</li><li>用于将模拟的设备连接到相关主机设备的通用设备。</li><li>调试器。</li><li>用来与模拟器交互的用户界面。</li></ul><h2 id="linux-2-6-22kernel记录"><a href="#linux-2-6-22kernel记录" class="headerlink" title="linux-2.6.22kernel记录"></a>linux-2.6.22<em>kernel</em>记录</h2><ul><li>主机：win10 x64</li><li>VM：Ubuntu1604</li><li>目标内核版本：Linux-2.6.22</li></ul><h3 id="内核编译"><a href="#内核编译" class="headerlink" title="内核编译"></a>内核编译</h3><p>Ubuntu 安装 <code>make menuconfig</code> 指令的依赖：<code>apt-get install libncurses5-dev</code>。<br>CentOS 安装 <code>make menuconfig</code> 指令的依赖：<code>yum install ncurses ncurses-devel</code>。</p><h4 id="Makefile问题"><a href="#Makefile问题" class="headerlink" title="Makefile问题"></a>Makefile问题</h4><p>版本差距太大，<code>Makefile</code> 存在个别地方语法的不兼容，借此顺便看了下 <code>Makefile</code> 的相关语法学习。</p><p>先放总结：make其实可以当作一个特制的shell执行器。对于中型or大型 <code>c/c++</code> 项目而言，因为头文件、依赖文件、各模块源码文件过多，如果每次编译都去手敲一次命令，非常不便且容易出错。于是就制作了 <code>make</code> 工具。</p><p>make工具的主要功能，将数量庞大的 <code>gcc编译命令</code> 格式化脚本化。格式化也就是相当于写个通项，然后根据这个通项自动生成每一条编译命令继而执行。模块化是对于不同的编译场景用户会有不同的编译需求，通过配置文件来将这些需求分化为不同的配置模块、命令模块、使其操作变得傻瓜化。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">A: B</span></span><br><span class="line">    shell code（C）</span><br></pre></td></tr></table></figure><p>A 代表所要编译生成的目标、B代表该目标的依赖文件（头文件、源码文件等等凡是用到的都可以是）、C代表具体的编译命令（也可以是一些 shell 中执行的命令）<br>当B集合中的文件时间戳发生变化，则make会对目标文件进行重新编译；否则make会跳过该目标的编译直接执行下一个目标的编译。</p><p>在<code>Makefile</code>中支持shell的一些基础语法，且make内置了一些功能函数。这里不多赘述</p><p>参考链接：</p><pre><code>- &lt;https://blog.51cto.com/u_15127598/4090088&gt;- &lt;https://zhuanlan.zhihu.com/p/442028798&gt;</code></pre><p>需要解决的地方：</p><p><img src="./makefile-1.png" alt="makefile-1"></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 415 行，对应报错信息</span></span><br><span class="line">config %config: scripts_basic outputmakefile FORCE</span><br><span class="line">        <span class="variable">$(Q)</span>mkdir -p <span class="keyword">include</span>/linux <span class="keyword">include</span>/config</span><br><span class="line">        <span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=scripts/kconfig <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1443 行，对应报错信息</span></span><br><span class="line">/ %/: prepare scripts FORCE</span><br><span class="line">        <span class="variable">$(cmd_crmodverdir)</span></span><br><span class="line">        <span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> KBUILD_MODULES=<span class="variable">$(<span class="built_in">if</span> <span class="variable">$(CONFIG_MODULES)</span>,1)</span> \</span><br><span class="line">        <span class="variable">$(build)</span>=$(build-dir)</span><br></pre></td></tr></table></figure><p>这里删除第一个 <code>config</code> 和 <code>/</code> ，如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 415</span></span><br><span class="line"><span class="section">%config: scripts_basic outputmakefile FORCE</span></span><br><span class="line">        <span class="variable">$(Q)</span>mkdir -p <span class="keyword">include</span>/linux <span class="keyword">include</span>/config</span><br><span class="line">        <span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> <span class="variable">$(build)</span>=scripts/kconfig <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1443</span></span><br><span class="line"><span class="section">%/: prepare scripts FORCE</span></span><br><span class="line">        <span class="variable">$(cmd_crmodverdir)</span></span><br><span class="line">        <span class="variable">$(Q)</span><span class="variable">$(MAKE)</span> KBUILD_MODULES=<span class="variable">$(<span class="built_in">if</span> <span class="variable">$(CONFIG_MODULES)</span>,1)</span> \</span><br><span class="line">        <span class="variable">$(build)</span>=$(build-dir)</span><br></pre></td></tr></table></figure><h4 id="内核配置问题"><a href="#内核配置问题" class="headerlink" title="内核配置问题"></a>内核配置问题</h4><p>如果是2.6.26版本的内核，会遭遇报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~/linux-2.6.26$ make -j4 | grep error</span><br><span class="line">Can<span class="string">&#x27;t use &#x27;</span>defined(@array)<span class="string">&#x27; (Maybe you should just omit the defined()?) at kernel/timeconst.pl line 373.</span></span><br><span class="line"><span class="string">make[1]: *** [kernel/timeconst.h] Error 255</span></span><br><span class="line"><span class="string">make: *** [kernel] Error 2</span></span><br><span class="line"><span class="string">make: *** Waiting for unfinished jobs....</span></span><br><span class="line"><span class="string">gcc: error: unrecognized command line option ‘-m’</span></span><br><span class="line"><span class="string">gcc: error: elf_x86_64: No such file or directory</span></span><br><span class="line"><span class="string">make[1]: *** [arch/x86/vdso/vdso.so.dbg] Error 1</span></span><br><span class="line"><span class="string">make: *** [arch/x86/vdso] Error 2</span></span><br></pre></td></tr></table></figure><p>修改 <code>arch/x86/vdso/Makefile</code> 中 <code>-m elf_x86_64</code> 为 <code>-m64</code> <code>-m elf_i386</code> <code>-m32</code>。<br>继续编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: .size expression <span class="keyword">for</span> copy_user_generic_c does not evaluate to a constant</span><br><span class="line">scripts/Makefile.build:238: recipe <span class="keyword">for</span> target <span class="string">&#x27;arch/x86_64/lib/copy_user.o&#x27;</span> failed</span><br></pre></td></tr></table></figure><p>去对应的源码文件查看错误出处</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ENTRY</span>(copy_user_generic_string)</span><br><span class="line">        CFI_STARTPROC</span><br><span class="line">        movl %ecx,%r8d          <span class="comment">/* save zero flag */</span></span><br><span class="line">        movl %edx,%ecx</span><br><span class="line">        shrl <span class="number">$3</span>,%ecx</span><br><span class="line">        andl <span class="number">$7</span>,%edx</span><br><span class="line">        jz   <span class="number">10</span>f</span><br><span class="line"><span class="number">1</span>:      rep</span><br><span class="line">        movsq</span><br><span class="line">        movl %edx,%ecx</span><br><span class="line"><span class="number">2</span>:      rep</span><br><span class="line">        movsb</span><br><span class="line"><span class="number">9</span>:      movl %ecx,%eax</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* multiple of 8 byte */</span></span><br><span class="line"><span class="number">10</span>:     rep</span><br><span class="line">        movsq</span><br><span class="line">        xor %eax,%eax</span><br><span class="line">        ret</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* exception handling */</span></span><br><span class="line"><span class="number">3</span>:      lea (%rdx,%rcx,<span class="number">8</span>),%rax  <span class="comment">/* exception on quad loop */</span></span><br><span class="line">        jmp <span class="number">6</span>f</span><br><span class="line"><span class="number">5</span>:      movl %ecx,%eax          <span class="comment">/* exception on byte loop */</span></span><br><span class="line">        <span class="comment">/* eax: left over bytes */</span></span><br><span class="line"><span class="number">6</span>:      testl %r8d,%r8d         <span class="comment">/* zero flag set? */</span></span><br><span class="line">        jz <span class="number">7</span>f</span><br><span class="line">        movl %eax,%ecx          <span class="comment">/* initialize x86 loop counter */</span></span><br><span class="line">        <span class="keyword">push</span> %rax</span><br><span class="line">        xorl %eax,%eax</span><br><span class="line"><span class="number">8</span>:      rep</span><br><span class="line">        stosb                   <span class="comment">/* zero the rest */</span></span><br><span class="line"><span class="number">11</span>:     <span class="keyword">pop</span> %rax</span><br><span class="line"><span class="number">7</span>:      ret</span><br><span class="line">        CFI_ENDPROC</span><br><span class="line"><span class="symbol">END</span>(copy_user_generic_c)</span><br></pre></td></tr></table></figure><p>可以发现是头尾名字不对应，<code>copy_user_generic_c</code> 改为 <code>copy_user_generic_string</code>。</p><hr><p>往后是通用报错</p><p>而后再次编译得到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kernel/built-in.o: In <span class="keyword">function</span> <span class="string">&#x27;mutex_lock&#x27;</span>:</span><br><span class="line">linux-2.6.22/kernel/mutex.c:91: undefined reference to <span class="string">&#x27;__mutex_lock_slowpath&#x27;</span></span><br><span class="line">kernel/built-in.o: In <span class="keyword">function</span> <span class="string">&#x27;mutex_unlock&#x27;</span>:</span><br><span class="line">linux-2.6.22/kernel/mutex.c:116: undefined reference to <span class="string">&#x27;__mutex_unlock_slowpath&#x27;</span></span><br></pre></td></tr></table></figure><p>跟踪源码发现，<code>CONFIG_DEBUG_MUTEXES</code> 影响了头文件的包含，与其有关：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;mutex-debug.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;asm-generic/mutex-null.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;mutex.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;asm/mutex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><code>grep -r</code> 搜索其出现的位置，找到如何影响的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grep -r CONFIG_DEBUG_MUTEXES .</span><br><span class="line">./.config:<span class="comment"># CONFIG_DEBUG_MUTEXES is not set</span></span><br></pre></td></tr></table></figure><p>在配置文件中设置为 y 。继续编译:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">arch</span>/x86_64/boot/compressed/misc.o: In <span class="keyword">function</span> <span class="string">&#x27;inflate_fixed&#x27;</span>:</span><br><span class="line">misc.c:(.text+0xf5a): undefined reference to <span class="string">&#x27;__stack_chk_fail&#x27;</span></span><br><span class="line"><span class="built_in">arch</span>/x86_64/boot/compressed/misc.o: In <span class="keyword">function</span> <span class="string">&#x27;inflate_dynamic&#x27;</span>:</span><br><span class="line">misc.c:(.text+0x14fa): undefined reference to <span class="string">&#x27;__stack_chk_fail&#x27;</span></span><br></pre></td></tr></table></figure><p>该报错是因为默认开启了栈保护策略，在 <code>Makefile</code> 中找到内核模块的编译参数，添加 <code>--fno-stack-protector</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHECKFLAGS     := -D__linux__ -Dlinux -D__STDC__ -Dunix -D__unix__ -Wbitwise <span class="variable">$(CF)</span></span><br><span class="line">MODFLAGS        = -DMODULE</span><br><span class="line">CFLAGS_MODULE   = <span class="variable">$(MODFLAGS)</span></span><br><span class="line">AFLAGS_MODULE   = <span class="variable">$(MODFLAGS)</span></span><br><span class="line">LDFLAGS_MODULE  = -r</span><br><span class="line">CFLAGS_KERNEL   = -fno-stack-protector</span><br><span class="line">AFLAGS_KERNEL   =</span><br></pre></td></tr></table></figure><p>出现以下内容说明内核编译完成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Root device is (8, 1) <span class="comment"># </span></span><br><span class="line">Boot sector 512 bytes.</span><br><span class="line">Setup is 7377 bytes.</span><br><span class="line">System is 2281 kB</span><br><span class="line">Kernel: <span class="built_in">arch</span>/x86_64/boot/bzImage is ready  (<span class="comment">#2)</span></span><br><span class="line">  MODPOST 1099 modules</span><br></pre></td></tr></table></figure><h3 id="qemu-运行"><a href="#qemu-运行" class="headerlink" title="qemu 运行"></a>qemu 运行</h3><p>为其制作基础文件系统。</p><p>先准备一个 <code>init</code> 程序。比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后制作虚拟介质并挂载。用 VM 类比就是 虚拟硬盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=myinitrd.img bs=4M count=1</span><br><span class="line">mkfs.ext3 myinitrd.img</span><br><span class="line"><span class="built_in">mkdir</span> rootfs</span><br><span class="line">sudo mount -o loop myinitrd.img rootfs</span><br></pre></td></tr></table></figure><p>这里刚制作的虚拟介质是空白的，需要填充文件系统的必要内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> init rootfs/</span><br><span class="line"><span class="built_in">cd</span> rootfs</span><br><span class="line">sudo <span class="built_in">mkdir</span> dev</span><br><span class="line">sudo <span class="built_in">mknod</span> dev/ram b 1 0</span><br><span class="line">sudo <span class="built_in">mknod</span> dev/console c 5 1</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">sudo umount rootfs</span><br></pre></td></tr></table></figure><p><code>mknod</code> 用于创建设备文件。</p><ul><li>参数为 <code>b</code> 时面向设备驱动，Linux下万物皆文件，通过该文件访问硬件驱动从而使用该硬件。</li><li>参数为 <code>c</code> 是面向字符。比如与打印机、控制台进行数据交互。</li><li>两个数字参数分别是主从设备号。在 Linux 下，设备集通过主设备号分类，每一个主设备号对应一大类设备的驱动，比如 <code>b 1</code> 就代表<code>ramdisk</code> 类型的设备；从设备号代表该类型设备集中具体的某个设备的序号。</li></ul><p>通过对应架构的qemu运行内核及刚制作的简易文件系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel path/bzImage -initrd path/myinitrd.img -m 512M --append <span class="string">&quot;root=/dev/ram init=/init&quot;</span></span><br></pre></td></tr></table></figure><p><code>bzImage</code> 是linux的内核镜像文件。是make编译时自动生成好的。内核文件的编译会有三个阶段，第一阶段是“裸内核”静态elf文件的编译生成；第二阶段会将其和 boot 程序 压缩成一个二进制文件 <code>vmlinux.bin</code>；第三阶段 会生成 <code>bzImage</code> 或者说 <code>vmlinuz</code>，可引导的压缩linux内核。通过 gzip 进行压缩。</p><p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/466591309">https://zhuanlan.zhihu.com/p/466591309</a></li><li><a href="https://www.shuzhiduo.com/A/RnJWm6GEdq/">https://www.shuzhiduo.com/A/RnJWm6GEdq/</a></li><li><a href="http://t.zoukankan.com/ldxsuanfa-p-9952120.html">http://t.zoukankan.com/ldxsuanfa-p-9952120.html</a></li><li><a href="https://blog.csdn.net/baidu_31504167/article/details/93606946">https://blog.csdn.net/baidu_31504167/article/details/93606946</a></li></ul><p>qemu启动过程中报错：提示挂载文件系统过程中不能识别到 <code>gzip header</code>，即 <code>myinitrd.img</code> 应该使用 gzip 压缩算法，这里先 直接 gzip 将其压缩一下康康什么效果。<br>发现这次提示找不 <code>cpio magic header</code>。查阅资料得知，linux2.6 内核支持两种格式的 initrd（虚拟文件系统），一种是 linux2.4 内核那种传统格式的文件系统镜像 <code>image-initrd</code>，其核心文件就是 <code>/linuxrc</code>；另外一种格式的 <code>initrd</code> 是 <code>cpio</code> 格式的，这种格式的 <code>initrd</code> 使用 <code>cpio</code> 工具生成，其核心文件不再是 <code>/linuxrc</code>，而是 <code>/init</code>。也就是说我们这里使用系统工具生产的虚拟介质其数据格式存在问题。我们手动压缩一个可用文件出来启动一下试试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo find path/rootfs -depth -<span class="built_in">print</span> | cpio -o -Hnewc | gzip -9 &gt; myinitrd.cpio.gz</span><br><span class="line">qemu-system-x86_64 -kernel path/bzImage -initrd path/myinitrd.img -m 512M --append <span class="string">&quot;root=/dev/ram init=/init&quot;</span></span><br></pre></td></tr></table></figure><p>挂载成功，但是提示 不能打开 <code>root 设备 ram（1，0）</code>。此时通过 <code>file</code> 命名查看前后两个文件系统文件的属性发现，第一次生成的文件属于硬盘，但第二次就只能算是个压缩归档文件了。推测应该是主设备号对应的驱动不对所以无法正常启动。这里我们可以通过修改 <code>内核配置</code> 的讲文件系统直接编译进内核镜像，让其编译时自动识别并包含。</p><p>到源码根路径 <code>make menuconfig</code>，修改 <code>General setup</code> 中选项，如下图：</p><p><img src="./makefile-2.png" alt="makefile-2"></p><p>编译过程中根据编译日志确认是因为主设备号错误导致无法正常启动，压缩文件类的文件系统主设备号使用 8 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  Building modules, stage 2.</span><br><span class="line">  OBJCOPY <span class="built_in">arch</span>/x86_64/boot/compressed/vmlinux.bin</span><br><span class="line">  GZIP    <span class="built_in">arch</span>/x86_64/boot/compressed/vmlinux.bin.gz</span><br><span class="line">  MODPOST 1099 modules</span><br><span class="line">  LD      <span class="built_in">arch</span>/x86_64/boot/compressed/piggy.o</span><br><span class="line">  LD      <span class="built_in">arch</span>/x86_64/boot/compressed/vmlinux</span><br><span class="line">  OBJCOPY <span class="built_in">arch</span>/x86_64/boot/vmlinux.bin</span><br><span class="line">  BUILD   <span class="built_in">arch</span>/x86_64/boot/bzImage</span><br><span class="line">Root device is (8, 1)</span><br><span class="line">Boot sector 512 bytes.</span><br><span class="line">Setup is 7382 bytes.</span><br><span class="line">System is 2643 kB</span><br><span class="line">Kernel: <span class="built_in">arch</span>/x86_64/boot/bzImage is ready  (<span class="comment">#6)</span></span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://blog.csdn.net/kunkliu/article/details/104838764">https://blog.csdn.net/kunkliu/article/details/104838764</a></li><li><a href="https://www.cnblogs.com/Andy-Lv/p/5304247.html">https://www.cnblogs.com/Andy-Lv/p/5304247.html</a></li></ul><p>再次运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-x86_64 -kernel path/bzImage -m 512M --append <span class="string">&quot;root=/dev/ram init=/init&quot;</span></span><br></pre></td></tr></table></figure><p><img src="./qemu-1.png" alt="qemu-1"></p><p>可以看到系统已经运转起来了，但是因为本地内核版本、gcc版本均高于目标，导致本地编译的程序运行时出现段错误异常。除此之外，在真机路由器上面使用较低版本gcc编译的静态程序时也会自检提示 内核版本太老无法运行。</p><p>一番苦苦挣扎，成功找到一个 09 年的仓库，存放了当年编译好的 各种架构的 gcc。下载尝试,终于成功运行起来</p><p>仓库地址：<a href="https://www.uclibc.org/downloads/binaries/0.9.30.1/">https://www.uclibc.org/downloads/binaries/0.9.30.1/</a></p><p><img src="./qemu-2.jpg" alt="qemu-2"></p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="Env" scheme="http://xibai.xyz/categories/Env/"/>
    
    
    <category term="Env" scheme="http://xibai.xyz/tags/Env/"/>
    
    <category term="IoT" scheme="http://xibai.xyz/tags/IoT/"/>
    
    <category term="Kernel" scheme="http://xibai.xyz/tags/Kernel/"/>
    
  </entry>
  
  <entry>
    <title>不同云服务商的云服务器搭建K8s集群</title>
    <link href="http://xibai.xyz/2022/03/10/%E6%90%AD%E5%BB%BAk8s%E6%97%B6%E9%81%87%E8%A7%81%E7%9A%84%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86/"/>
    <id>http://xibai.xyz/2022/03/10/%E6%90%AD%E5%BB%BAk8s%E6%97%B6%E9%81%87%E8%A7%81%E7%9A%84%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86/</id>
    <published>2022-03-10T03:29:42.000Z</published>
    <updated>2024-07-19T07:15:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>近期因为学习需要，所以整了两台云服务器给自己搭个简易k8s集群。中间因为中文互联网太乱，k8s的官方文档写的不太适合国人参考，所以中间被折磨了几天，这里做一次踩坑记录。</p><p>!!! console 作为控制节点的服务器最低配置为 2核4G</p><h2 id="节点通信要求"><a href="#节点通信要求" class="headerlink" title="节点通信要求"></a>节点通信要求</h2><p>k8s默认一般搭建场景都是在同一局域网网段中，但这里我们是在云服务器（不同云服务商的产品）上面搭建环境，所以我们需要进行路由设置从而让两个服务器的通信如同在同一局域网网段下一样，类似：</p><ul><li>发送时：k8s节点a -&gt; k8s节点b局域网网段ip -&gt; k8s节点b公网ip -&gt; k8s节点b<ul><li>k8s节点a -&gt; k8s节点b局域网网段ip：这里目标ip为k8s节点b的局域网ip。这个局域网ip，是指k8s节点b加入k8s集群时所指定的其本地某网卡的本地ip值，一般情况下都用eth0网卡。</li><li>k8s节点b局域网网段ip -&gt; k8s节点b公网ip：这里就是一个简单的IP地址转换，用iptables写一个nat规则就可以，将发往k8s节点b局域网网段ip的数据包改为发往k8s节点b公网ip。</li></ul></li><li>接收时：k8s节点b公网ip -&gt; k8s节点b<br>这里需要把从k8s节点a发来的数据包的源ip从k8s节点b公网ip改回k8s节点a的局域网ip</li></ul><p>如此一来，对于两个或多个跨云服务商的服务器，才能让其如同在同一局域网网段下一样通信，这样后续搭建k8s集群的通信基础就有了，可以避免非常多的报错。</p><p>Linux其添加NAT规则的命令：</p><blockquote><p>原本只需要设置nat表中的output和input两种规则即可，但不知道是Linux内核的功能更新还是Ubuntu的系统更新，导致其中input规则链相当于无效了。<br>不过好在k8s的核心本体是本地容器的，而容器网络构建则是通过另外的内部虚拟网卡进行的，也即容器与外部互联网通信时需要经过eth0网卡转发，故而我们添加 PREROUTING、POSTROUTING 两种规则即可解决 input 无效的问题</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 出站时</span></span><br><span class="line">iptables -t nat -I OUTPUT -d 目标节点内网ip -j DNAT --to 目标节点的公网IP</span><br><span class="line">iptables -t nat -I PREROUTING -d 目标节点内网ip -j DNAT --to 目标节点的公网IP</span><br><span class="line"><span class="comment"># 入站时</span></span><br><span class="line">iptables -t nat -I INPUT -s 源节点的公网ip -j SNAT --to-source 源节点的局域网ip</span><br><span class="line">iptables -t nat -I POSTROUTING -s 源节点的公网ip -j SNAT --to-source 源节点的局域网ip</span><br></pre></td></tr></table></figure><p>然后是k8s的网络基础配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/k8s.conf</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/k8s.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><h2 id="Linux-纯命令行版代理使用"><a href="#Linux-纯命令行版代理使用" class="headerlink" title="Linux-纯命令行版代理使用"></a>Linux-纯命令行版代理使用</h2><p>这里因为是在云服务器上面搭环境，所以代理这个基建问题就不得不再次提了出来。如果是本地Linux虚拟机或者docker容器，其不管什么情况走本地代理就像加个参数一样简单，且几乎所有常见协议都能正常运行。<br>然鹅我在命令行版本的Linux系统云服务器上使用代理时，这里在网上扒了几个可以连接机场的代理之后，可以说是，每一个参考文章的结果都难用至极（ps：这里仅讨论纯命令行版本的代理工具，图形化界面的工具只看大佬们的截图应该挺好用的。）</p><p>最后在github上翻到了目前主流SSR小飞机的初代官方开源版本：<a href="https://github.com/maxsky/shadowsocksr-manyuser">https://github.com/maxsky/shadowsocksr-manyuser</a></p><p>这里的话，修改 <code>config.json</code> 为对应的机场的配置：</p><p><img src="ssr-1.png" alt="ssr-1"></p><p><img src="ssr-2.png" alt="ssr-1"></p><p>然后进入 <code>shadowsocksr</code> 文件夹，执行 <code>local.py</code> 文件即可开启本地代理。</p><p>然后在终端中添加环境变量：http_proxy=socks5://127.0.0.1:你上面配置文件指定的本地端口就可以正常使用代理了。</p><p>这里注意，据本人测试，在使用其开启的本地代理时，仅支持 socks5 协议，且某些情况下无法通过该代理方式进行正常通信。例如：</p><ul><li>腾讯云源or阿里云源的<code>apt update</code></li><li>curl 通过其访问一些网站如 www.google.com</li></ul><p>这里补充一个很容易搜到的点：</p><ul><li>apt使用socks5协议参数格式为：<code>-o Acquire::http::proxy=&quot;socks5h://127.0.0.1:port/&quot;</code></li></ul><p>另外尝试过后已知docker拉取镜像时无法通过该代理方式，还是需要下载国内源。</p><h2 id="k8s组件准备"><a href="#k8s组件准备" class="headerlink" title="k8s组件准备"></a>k8s组件准备</h2><h3 id="容器运行时"><a href="#容器运行时" class="headerlink" title="容器运行时"></a>容器运行时</h3><p>这里的话其实可以直接去看k8s的官方文档或者参考该文章：<a href="https://zhuanlan.zhihu.com/p/102171749">https://zhuanlan.zhihu.com/p/102171749</a>，我仅做了搭建过程的简单记录。<br>这里我测试了三种容器运行时的安装，如要使用其他容器进行时请自行查阅资料</p><h4 id="docker-containerd"><a href="#docker-containerd" class="headerlink" title="docker | containerd"></a>docker | containerd</h4><h5 id="containerd准备"><a href="#containerd准备" class="headerlink" title="containerd准备"></a>containerd准备</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/containerd.conf</span></span><br><span class="line"><span class="string">overlay</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sudo modprobe overlay</span><br><span class="line">sudo modprobe br_netfilter</span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup required sysctl params, these persist across reboots.</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables  = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward                 = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Apply sysctl params without reboot</span></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><h5 id="配置docker官方源"><a href="#配置docker官方源" class="headerlink" title="配置docker官方源"></a>配置docker官方源</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg \</span><br><span class="line">    lsb-release</span><br><span class="line"></span><br><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure><h5 id="安装docker-containerd"><a href="#安装docker-containerd" class="headerlink" title="安装docker|containerd"></a>安装docker|containerd</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install docker-ce docker-ce-cli containerd.io docker.io</span><br></pre></td></tr></table></figure><p>配置containerd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /etc/containerd</span><br><span class="line">containerd config default | <span class="built_in">tee</span> /etc/containerd/config.toml</span><br></pre></td></tr></table></figure><p>重启containerd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure><p>检测docker安装是否正常完成</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><h5 id="【选择】设置docker-containerd的cgroup驱动"><a href="#【选择】设置docker-containerd的cgroup驱动" class="headerlink" title="【选择】设置docker|containerd的cgroup驱动"></a>【选择】设置docker|containerd的cgroup驱动</h5><ul><li>containerd： 在 <code>/etc/containerd/config.toml</code> 中设置  <figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc]</span></span><br><span class="line">...</span><br><span class="line"><span class="section">[plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc.options]</span></span><br><span class="line">    <span class="attr">SystemdCgroup</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li>docker：修改或创建 <code>/etc/docker/daemon.json</code>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;exec-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;native.cgroupdriver=systemd&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload <span class="comment"># 重载配置</span></span><br><span class="line">systemctl restart docker <span class="comment"># 重启服务</span></span><br></pre></td></tr></table></figure><p>查看docker的cgroup是什么：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker info | grep ‘Cgroup’ <span class="comment">#查看</span></span><br><span class="line"><span class="comment"># 结果：Cgroup Driver: cgroupfs</span></span><br></pre></td></tr></table></figure><p>以上两种举例都是将其cgroup驱动设置为<code>systemd</code>,还有另一种对应驱动程序叫做：<code>cgroupfs</code></p><h4 id="cri-o"><a href="#cri-o" class="headerlink" title="cri-o"></a>cri-o</h4><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create the .conf file to load the modules at bootup</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/modules-load.d/crio.conf</span></span><br><span class="line"><span class="string">overlay</span></span><br><span class="line"><span class="string">br_netfilter</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sudo modprobe overlay</span><br><span class="line">sudo modprobe br_netfilter</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up required sysctl params, these persist across reboots.</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/sysctl.d/99-kubernetes-cri.conf</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-iptables  = 1</span></span><br><span class="line"><span class="string">net.ipv4.ip_forward                 = 1</span></span><br><span class="line"><span class="string">net.bridge.bridge-nf-call-ip6tables = 1</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><p>设置两个环境变量，一个是 <code>VERSION</code> ,一个是 <code>OS</code></p><div class="table-container"><table><thead><tr><th>your OS version</th><th>$OS</th></tr></thead><tbody><tr><td>Ubuntu 20.04</td><td>xUbuntu_20.04</td></tr><tr><td>Ubuntu 19.10</td><td>xUbuntu_19.10</td></tr><tr><td>Ubuntu 19.04</td><td>xUbuntu_19.04</td></tr><tr><td>Ubuntu 18.04</td><td>xUbuntu_18.04</td></tr></tbody></table></div><p><code>VERSION</code> 则是与你的k8s版本对应的 <code>cri-o</code> 的版本。<code>VERSION</code> 的写法格式：<br>比如只是指定大版本如 <code>CRI-O 1.20</code>, VERSION=1.20 。<br>如果是具体到某个小版本如 <code>version 1.20.0</code>, <code>VERSION=1.20:1.20.0</code><br>参考:<a href="https://github.com/cri-o/cri-o#compatibility-matrix-cri-o--kubernetes">https://github.com/cri-o/cri-o#compatibility-matrix-cri-o--kubernetes</a></p><h5 id="安装cri-o"><a href="#安装cri-o" class="headerlink" title="安装cri-o"></a>安装cri-o</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable.list</span></span><br><span class="line"><span class="string">deb https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/$OS/ /</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>接下来的这些命令有细节需要注意：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF | sudo tee /etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list</span></span><br><span class="line"><span class="string">deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/<span class="variable">$OS</span>/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers.gpg add -</span><br><span class="line">curl -L https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/<span class="variable">$VERSION</span>/<span class="variable">$OS</span>/Release.key | sudo apt-key --keyring /etc/apt/trusted.gpg.d/libcontainers-cri-o.gpg add -</span><br><span class="line"></span><br><span class="line">apt update</span><br><span class="line">apt install cri-o cri-o-runc</span><br></pre></td></tr></table></figure><p>对于 <code>deb http://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/$VERSION/$OS/ /</code>，应该可以发现，每个 <code>:</code> 后面都跟了一个斜杠，但我们拼接上去的VERSION如果指定了小版本的话是存在 <code>:</code> 的，但却没有斜杠，所以这里需要去 <code>/etc/apt/sources.list.d/devel:kubic:libcontainers:stable:cri-o:$VERSION.list</code> 里做修改。</p><p>另外，本人在对其安装的时候发现，我所指定的小版本却没有存在于官方源仓库，所以如果有人参考本文安装cri-o时发现：<br><code>curl -L https://download.opensuse.org/repositories/devel:kubic:libcontainers:stable:cri-o:$VERSION/$OS/Release.key</code> 报错404，是正常现象，访问 <code>https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable:/cri-o:/</code> 找到离目标版本最接近的版本，使用该版本即可，记得 <code>:</code> 后面的斜杠</p><p>启动cri-o：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> crio --now</span><br></pre></td></tr></table></figure><h5 id="【选择】设置cri-o的cgroup驱动"><a href="#【选择】设置cri-o的cgroup驱动" class="headerlink" title="【选择】设置cri-o的cgroup驱动"></a>【选择】设置cri-o的cgroup驱动</h5><p><code>cri-o</code> 默认使用 <code>systemd</code>，如果要修改为 <code>cgroupfs</code>，去 <code>/etc/crio/crio.conf</code> or <code>/etc/crio/crio.conf.d/02-cgroup-manager.conf</code> 中添加或修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[crio.runtime]</span><br><span class="line">conmon_cgroup = &quot;pod&quot;</span><br><span class="line">cgroup_manager = &quot;cgroupfs&quot;</span><br></pre></td></tr></table></figure><h3 id="kube-套件"><a href="#kube-套件" class="headerlink" title="kube 套件"></a>kube 套件</h3><p>这里便是需要使用代理的地方，k8s需要使用三个工具，其中 <code>kubeadm</code> 使用谷歌自己的源仓库（本人在配置环境时此刻并未发现国内存在kubeadm的源，如果有人参考本文时发现存在相应的国内源的话反而不需要代理），所以国内云服务器必须使用机场or其他科学上网服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install -y apt-transport-https ca-certificates curl</span><br><span class="line">curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg <span class="comment"># 这里如果执行失败可以手工在本地把对应的gpg密钥下载下来用ssh发送给服务器</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main&quot;</span> | sudo <span class="built_in">tee</span> /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">apt update <span class="comment"># 记得代理，不然无法访问谷歌源仓库，另外记得注释掉配置文件中本地的腾讯源和阿里源</span></span><br><span class="line">apt install -y kubelet kubeadm kubectl</span><br><span class="line">apt-mark hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><h2 id="启动k8s集群"><a href="#启动k8s集群" class="headerlink" title="启动k8s集群"></a>启动k8s集群</h2><h3 id="镜像准备"><a href="#镜像准备" class="headerlink" title="镜像准备"></a>镜像准备</h3><p>这里尝试了一整天的代理方式给k8s拉取官方镜像，无奈命令行版本的Linux的代理工具过于拉跨，只能下载国内源的镜像。<br>这里我们首先通过：<code>kubeadm config image list</code> 列出需要拉取的镜像版本，然后将谷歌的仓库地址：<code>k8s.gcr.io/</code> 换成国内的仓库地址：<code>registry.aliyuncs.com/google_containers/</code>，并直接通过 <code>docker pull</code> 进行拉取，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.23.4</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.23.4</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.23.4</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-proxy:v1.23.4</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/pause:3.6</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/etcd:3.5.1-0</span><br><span class="line">docker pull registry.aliyuncs.com/google_containers/coredns/coredns:v1.8.6</span><br></pre></td></tr></table></figure><p>之后将我们拉取的镜像名字改为谷歌源对应的名字，其实就是把仓库前缀手工改回去，类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.23.4 k8s.gcr.io/kube-apiserver:v1.23.4</span><br></pre></td></tr></table></figure><h3 id="cgroup设置"><a href="#cgroup设置" class="headerlink" title="cgroup设置"></a>cgroup设置</h3><p>前面又说到，这个驱动有两种，启动k8s集群之前必须将 k8s 的 cgroup 驱动设置为和容器运行时一样，不然会有环境冲突导致初始化启动失败。</p><p>这里我修改了 <code>cgroup</code> 为 <code>cgroupfs</code></p><ul><li>k8s配置：修改 <code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Environment=<span class="string">&quot;……(意思是省略号，前面内容不改，直接空格添加) --cgroup-driver=cgroupfs&quot;</span></span><br></pre></td></tr></table></figure><p>然后重载重启k8s</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> kubelet &amp;&amp; systemctl restart kubelet</span><br></pre></td></tr></table></figure><h3 id="初始化启动"><a href="#初始化启动" class="headerlink" title="初始化启动"></a>初始化启动</h3><ul><li><code>--control-plane-endpoint</code> 该参数可以当作是设置中心控制节点的地址，可以是ip也可以是域名；</li><li><code>--cri-socket</code> 该参数指定k8s所用容器运行时。这里本人用的docker，对应的本地socket为 <code>/var/run/dockershim.sock</code></li><li><code>--pod-network-cidr</code> 该参数指定一个网段如：<code>100.100.100.100/16</code>，该网段可以理解为为k8s集群指定的能直接通信不需要nat转换ip的网段。而该网段之外的其他ip如果要与k8s节点通信则需要nat转换，具体的话可以参考该文章：<a href="https://blog.csdn.net/shida_csdn/article/details/104334372">https://blog.csdn.net/shida_csdn/article/details/104334372</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --control-plane-endpoint ip或者域名 --cri-socket /var/run/dockershim.sock </span><br></pre></td></tr></table></figure><p>运行成功后有如下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now <span class="built_in">join</span> any number of control-plane nodes by copying certificate authorities</span><br><span class="line">and service account keys on each node and <span class="keyword">then</span> running the following as root:</span><br><span class="line"></span><br><span class="line">  kubeadm <span class="built_in">join</span> xxxxxxxxxxx:6443 --token xxxxxxxxxxcfm7gtu \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:xxxxxxxxxxxxxxxxxxx8a498ff611faafe5285560558f2d700d8d2 \</span><br><span class="line">        --control-plane</span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> xxxxx:6443 --token xxxxxxxxcfm7gtu \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:xxxxxxxxxxxxxxxxxxxx8a498ff611faafe5285560558f2d700d8d2</span><br></pre></td></tr></table></figure><p>这里会英语或者谷歌翻译一下就懂了，不再额外解释。</p><h3 id="pods网络设置"><a href="#pods网络设置" class="headerlink" title="pods网络设置"></a>pods网络设置</h3><p>前文有简单提到说k8s是在本地局域网网段下通信，而其网络通信所用的策略或者说机制或者说组件便是这部分配置。前面的路由设置也是为这里准备，节点的平常通信基本都是通过我们使用的pods组件实现。</p><p>这里我们使用 <code>calico</code> 组件。</p><h4 id="配置文件准备"><a href="#配置文件准备" class="headerlink" title="配置文件准备"></a>配置文件准备</h4><p>先从官网下载初始配置文件：<a href="https://projectcalico.docs.tigera.io/manifests/calico.yaml">https://projectcalico.docs.tigera.io/manifests/calico.yaml</a></p><p>然后在其中该位置 <code>spec.template.spec.containers.env</code> ：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The default IPv4 pool to create on startup if none exists. Pod IPs will be</span></span><br><span class="line"><span class="comment"># chosen from this range. Changing this value after installation will have</span></span><br><span class="line"><span class="comment"># no effect. This should fall within `--cluster-cidr`.</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CALICO_IPV4POOL_CIDR</span> <span class="comment">#这一个环境变量官方配置文件中应该是注释状态</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">你设置的--pod-network-cidr</span> <span class="string">参数</span></span><br><span class="line"><span class="comment"># Disable file logging so `kubectl logs` works.</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CALICO_DISABLE_FILE_LOGGING</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="comment"># Set Felix endpoint to host default action to ACCEPT.</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">FELIX_DEFAULTENDPOINTTOHOSTACTION</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">&quot;ACCEPT&quot;</span></span><br></pre></td></tr></table></figure><p>添加如下字段：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">IP_AUTODETECTION_METHOD</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">&quot;interface=eth0&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">KUBERNETES_SERVICE_HOST</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">&quot;你指定的控制节点服务器的公网ip或者域名&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">KUBERNETES_SERVICE_PORT</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">&quot;6443&quot;</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">KUBERNETES_SERVICE_PORT_HTTPS</span></span><br><span class="line">  <span class="attr">value:</span> <span class="string">&quot;6443&quot;</span></span><br></pre></td></tr></table></figure><h4 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f 修改后的calico.yaml的路径</span><br></pre></td></tr></table></figure><h4 id="安装calico管理工具"><a href="#安装calico管理工具" class="headerlink" title="安装calico管理工具"></a>安装calico管理工具</h4><p>github下载最新版本的控制工具：<a href="https://github.com/projectcalico/calico/releases/">https://github.com/projectcalico/calico/releases/</a><br>将其重命名为：calicoctl，并赋予执行权限</p><h3 id="查看k8s集群状态"><a href="#查看k8s集群状态" class="headerlink" title="查看k8s集群状态"></a>查看k8s集群状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看节点状态</span></span><br><span class="line">kubectl get nodes -o wide</span><br><span class="line"><span class="comment"># 查看pods状态</span></span><br><span class="line">kubectl get pods -o wide --all-namespaces</span><br><span class="line"><span class="comment"># 查看calico网络状态</span></span><br><span class="line">./calicoctl node status</span><br></pre></td></tr></table></figure><p><img src="nodes.png" alt="nodes"><br><img src="pods.png" alt="pods"><br><img src="calico.png" alt="calico"></p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="Env" scheme="http://xibai.xyz/categories/Env/"/>
    
    
    <category term="Env" scheme="http://xibai.xyz/tags/Env/"/>
    
    <category term="k8s" scheme="http://xibai.xyz/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>铁威马F2-420_4.1.27固件逆向分析</title>
    <link href="http://xibai.xyz/2022/02/24/%E9%93%81%E5%A8%81%E9%A9%ACF2-420-4-1-27%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/"/>
    <id>http://xibai.xyz/2022/02/24/%E9%93%81%E5%A8%81%E9%A9%ACF2-420-4-1-27%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/</id>
    <published>2022-02-24T02:57:21.000Z</published>
    <updated>2022-02-24T02:57:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>IDA7.x 64位</li><li>铁威马F2-420_4.1.27系统固件</li></ul><p>在官网上下载对应的系统固件(TOS_S2.0_Install_X64_4.1.27_2006301044_2006301431.ins)：</p><p><img src="download-1.png" alt="download-1"><br><img src="download-2.png" alt="download-2"></p><h2 id="解包"><a href="#解包" class="headerlink" title="解包"></a>解包</h2><p>这里先看一下 <code>ins</code> 后缀名的固件包的结构，分析如何解包获取源文件。<br><code>winhex</code> 打开发现是个 <code>bz</code> 压缩包。<code>bandzip</code> 可以直接解压缩：</p><p><img src="bz-1.png" alt="bz-1"></p><p>如果用 <code>WinRAR</code> 虽然也能解压缩但是会是这个样子：</p><p><img src="bz-2.png" alt="bz-2"></p><p>这里一开始是用了 <code>WinRAR</code> 解压缩，于是无奈分析了一下解压缩之后的这个文件的格式发现<strong>可以理解为一个简易但不规范的文件系统</strong>。</p><p>上图中最开始的 <code>./</code> 即文件（夹）对应的路径；后面的 <code>0000755</code> 即对应文件（夹）的权限设置，后面的连续数字参数未发现含义，既不是数据偏移也不是时间戳，可以略过；最后一个单个数字参数，即上图中的 <code>5</code> ，指代类型，<code>5</code> 指代文件夹、<code>0</code> 或者 <code>2</code> 都指代文件。<br>其中连续数据区域（单个数据块）大小为 <code>200bytes</code>。并未发现文件大小对应的参数，简单下个脚本手工提取一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">dir_path = <span class="string">&#x27;./TOS_file&#x27;</span></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;TOS_S2.0_Install_X64_4.1.27_2006301044_2006301431&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    tmp = f.read(<span class="number">0x200</span>) ; num += <span class="number">0x200</span></span><br><span class="line">    tmp = f.read(<span class="number">0x200</span>) ; num += <span class="number">0x200</span></span><br><span class="line">    tmpfile = <span class="built_in">open</span>(<span class="string">&#x27;tmp&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">    <span class="keyword">while</span> tmp != <span class="string">b&#x27;&#x27;</span>:</span><br><span class="line">        <span class="keyword">if</span> tmp[<span class="number">0x60</span>:<span class="number">0x68</span>] != <span class="string">b&#x27;\x00\x00\x00\x000000&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">b&#x27;GH65Hws2jedf3fl3MeK&#x27;</span> <span class="keyword">in</span> tmp:</span><br><span class="line">                <span class="built_in">print</span>(file_path)</span><br><span class="line">            tmpfile.write(tmp)</span><br><span class="line">        <span class="keyword">elif</span> tmp[:<span class="number">2</span>] == <span class="string">b&#x27;./&#x27;</span>:</span><br><span class="line">            index = tmp.index(<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">            tmp = tmp.replace(<span class="string">b&#x27;:&#x27;</span>,<span class="string">b&#x27;-&#x27;</span>)</span><br><span class="line">            file_path = dir_path+tmp[<span class="number">1</span>:index].decode()</span><br><span class="line">            <span class="keyword">if</span> tmp[<span class="number">0x9c</span>] == <span class="number">0x35</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(file_path):</span><br><span class="line">                    os.makedirs(file_path)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tmpfile.close()</span><br><span class="line">                tmpfile = <span class="built_in">open</span>(file_path,<span class="string">&#x27;wb&#x27;</span>)</span><br><span class="line">        tmp = f.read(<span class="number">0x200</span>) ; num += <span class="number">0x200</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\r%f&#x27;</span>%(num/<span class="number">0x1f1ff800</span>),end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>拿到系统固件中的全部源文件之后开始分析。先简单搜索一下关键字定位关键代码文件的位置：<code>/usr/www</code>。</p><p>简单查看几个php文件发现除了极个别不是很重要的文件之外全部加密了。而且具备规律：</p><blockquote><p>加密的php文件前十六进制都一样疑似hash值或某种key，跟着往后十六字节是记录的文件加密前的大小（可以看到该数字与文件剩余数据的大小的差值小于16且文件数据大小一定为16的整数倍，符合aes、des等常用对称密码特征）。</p></blockquote><p><img src="php-1.png" alt="php-1"></p><p>这里猜测应该是魔改了 <code>php</code> 二进制程序，在服务启动时应该会解密这些php文件进行运行。找到php文件进行逆向分析，尝试定位解密代码。php 程序位置：<code>/usr/sbin/php</code>。</p><p>在ida中跟进代码逻辑未能发现可疑函数与可疑字符串，但在对特征值的搜索中，检索到一片文章：<a href="https://blog.securityevaluators.com/terramaster-nas-vulnerabilities-discovered-and-exploited-b8e5243e7a63">TerraMaster NAS Vulnerabilities Discovered and Exploited</a></p><p>该文章对同型号的历史版本固件进行了分析并发现了可利用漏洞。其中就有涉及 php加密文件 解密的内容。在该文章中得知开发者在历史版本中曾写死了 <code>aes</code> 的加密密钥，其中直接将对应的明文字符串 <code>GH65Hws2jedf3fl3MeK</code> 写进了程序，这里可以直接在 <code>winRAR</code> 解压出来的简易文件系统中暴力匹配该字符串，定位到该字符串位于php的依赖文件：<code>/usr/lib/php/modules/php_terra_master.so</code> 中。这里<strong>其实在一开始对</strong> <code>php</code> <strong>二进制程序本身逆向无果时可以尝试寻找其对应的依赖文件进行搜索找到，文件名字特征过于明显</strong>。</p><p>ida分析该文件定位到相关的解密函数：</p><p><img src="php-2.png" alt="php-2"></p><p>这里起初以为 <code>screw_aes</code> 是魔改的 <code>aes</code> 算法，后跟进分析发现开发者并未对其进行本质改动。主要是在原 <code>screw_aes</code> 的基础上在aes加密出口和解密入口添加了一个异或。异或值与上图中函数 <code>teg_yek</code> 的返回值有关。我们跟进分析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __fastcall <span class="title function_">teg_yek</span><span class="params">(FILE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> v1; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v2; <span class="comment">// dl</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">256</span>]; <span class="comment">// [rsp+0h] [rbp-208h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">264</span>]; <span class="comment">// [rsp+100h] [rbp-108h] BYREF</span></span><br><span class="line"></span><br><span class="line">  fileno(a1);</span><br><span class="line">  php_sprintf((__int64)v4, <span class="string">&quot;/proc/self/fd/%d&quot;</span>);</span><br><span class="line">  v1 = readlink(v4, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  v2 = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v1 &gt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> v4[v1 + <span class="number">251</span>];</span><br><span class="line">  <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过 <code>php_sprintf</code> 将目标php文件的文件链接路径写入<code>v4</code>，然后通过该链接直接读取文件内容放入到 <code>buf</code>中，如果函数执行成功，返回 <code>v4[v1+251]</code>，即 <code>v5[v1-5]</code>。即：取读取到的倒数第五个字节的数据去和加密数据进行异或，然后进行 <code>screw_aes</code> 的解密操作。</p><p>这里在直接写 <code>aes</code> 解密时未能成功。前文提到第一遍分析的时候以为是开发者魔改了aes算法也是因为这里未能解密，后续查阅资料找到一个开源工具：</p><p><img src="php-3.png" alt="php-3"></p><p>翻阅该开源工具确认开发者是基于该工具做的二次开发。我们下载源码编译一个未做改动的可执行程序用ida加载，与该固件的 <code>php_terra_master.so</code> 中的代码进行对比。可以确认开发者确实只添加了一个异或处理。这里猜测此处应该是历史版本遗留，因为在最初的 <code>php</code> 二进制文件逆向中并未找到其调用 <code>screw</code> 相关的函数，其中也没有写入明文字符串 <code>GH65Hws2jedf3fl3MeK</code>，所以猜测开发者应该修改了这里的异或逻辑。但考虑到我们拿到的加密php文件规律与历史版本吻合，所以猜测开发者只是增加了 <code>php</code> 二进制文件中解密代码的逆向难度与异或字节的取值方式，尝试遍历单字节异或的所有可能逐一进行解密操作，得到源代码。</p><p>爆破脚本，<code>twmnas.exe</code> 使用开源工具中的解密部分代码编译：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;Enter.php&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    debug_cipher = f.read()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;debug/enter&#x27;</span>+<span class="built_in">str</span>(i).zfill(<span class="number">3</span>)+<span class="string">&#x27;.php&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> o:</span><br><span class="line">            o.write(debug_cipher[:<span class="number">32</span>])</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> debug_cipher[<span class="number">32</span>:]:</span><br><span class="line">                o.write((i^j).to_bytes(<span class="number">1</span>,<span class="string">&#x27;big&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        os.system(<span class="string">&#x27;twmnas.exe ./debug/enter&#x27;</span>+<span class="built_in">str</span>(i).zfill(<span class="number">3</span>)+<span class="string">&#x27;.php&#x27;</span>+<span class="string">&#x27; -d&#x27;</span>)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;debug/enter&#x27;</span>+<span class="built_in">str</span>(i).zfill(<span class="number">3</span>)+<span class="string">&#x27;.php&#x27;</span>,<span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> o:</span><br><span class="line">            <span class="keyword">if</span> o.read(<span class="number">1</span>) == <span class="string">b&#x27;&lt;&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="php-4.png" alt="php-4"><br><img src="php-5.png" alt="php-5"></p><p>在另外的php文件上尝试也解密成功。至此，解密完成。</p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="Iot" scheme="http://xibai.xyz/categories/Iot/"/>
    
    
    <category term="Re" scheme="http://xibai.xyz/tags/Re/"/>
    
    <category term="Iot" scheme="http://xibai.xyz/tags/Iot/"/>
    
  </entry>
  
  <entry>
    <title>汐白のHEVD学习-Windows内核知识</title>
    <link href="http://xibai.xyz/2022/02/18/%E6%B1%90%E7%99%BD%E3%81%AEHEVD%E5%AD%A6%E4%B9%A0-windows%E5%86%85%E6%A0%B8%E7%9F%A5%E8%AF%86/"/>
    <id>http://xibai.xyz/2022/02/18/%E6%B1%90%E7%99%BD%E3%81%AEHEVD%E5%AD%A6%E4%B9%A0-windows%E5%86%85%E6%A0%B8%E7%9F%A5%E8%AF%86/</id>
    <published>2022-02-18T10:25:00.000Z</published>
    <updated>2022-02-18T10:25:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于用户态和内核态"><a href="#关于用户态和内核态" class="headerlink" title="关于用户态和内核态"></a>关于用户态和内核态</h2><p>这里直接放一个官方的用户模式与内核模式说明：</p><h3 id="用户模式"><a href="#用户模式" class="headerlink" title="用户模式"></a>用户模式</h3><p>当您启动用户模式应用程序时，Windows 会为该应用程序创建一个进程。该进程为应用程序提供了一个私有虚拟地址空间和一个私有句柄表。因为应用程序的虚拟地址空间是私有的，所以一个应用程序不能更改属于另一个应用程序的数据。每个应用程序都是独立运行的，如果一个应用程序崩溃，崩溃仅限于那个应用程序。其他应用程序和操作系统不受崩溃影响。</p><p>除了私有之外，用户模式应用程序的虚拟地址空间也是有限的。在用户模式下运行的处理器无法访问为操作系统保留的虚拟地址。限制用户模式应用程序的虚拟地址空间可防止应用程序更改并可能损坏关键操作系统数据。</p><h3 id="内核模式"><a href="#内核模式" class="headerlink" title="内核模式"></a>内核模式</h3><p>在内核模式下运行的所有代码共享一个虚拟地址空间。这意味着内核模式驱动程序不与其他驱动程序和操作系统本身隔离。如果内核模式驱动程序意外写入错误的虚拟地址，则属于操作系统或其他驱动程序的数据可能会受到损害。如果内核模式驱动程序崩溃，整个操作系统就会崩溃。（ps，内核驱动开发极易蓝屏的原因）</p><p>此图说明了用户模式和内核模式组件之间的通信。</p><p><img src="汐白のHEVD学习-windows内核知识/userandkernelmode01.png" alt="userandkernel-0"></p>]]></content>
    
    
      
      
        
        
    <summary type="html"></summary>
        
      
    
    
    
    <category term="Pwn" scheme="http://xibai.xyz/categories/Pwn/"/>
    
    
    <category term="Pwn" scheme="http://xibai.xyz/tags/Pwn/"/>
    
    <category term="Windows" scheme="http://xibai.xyz/tags/Windows/"/>
    
  </entry>
  
</feed>
